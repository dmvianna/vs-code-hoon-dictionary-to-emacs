{
    "|$": "<p><code>|$</code> \"barbuc\"</p>\n\n<p>Declares a mold builder wet gate with one or more molds as its sample.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |$  sample<p>  body<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  |$(sample body)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brbc sample=(lest term) body=spec]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n|$  [a b]\nbody\n</pre></code></p>\n\n<p>becomes</p>\n\n<p><code><pre>\n|*  [a=$~(* $-(* <em>)) b=$~(</em> $-(* *))]\n^:\nbody\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p><code>|$</code> is used to declare a wet gate mold builder that is polymorphic in its input\nmolds. <code>a</code> is a <code>lest</code> of <code>term</code> used as identifiers for the input molds. <code>b</code> is\na structure built from elements of <code>a</code>. The output of <code>|$</code> is a mold builder\nobtained by substituting the input molds parameterized by <code>a</code> into <code>b</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>A mold builder is a wet gate from one or more molds to a mold. A mold is a\nfunction from nouns to nouns with types that may be partial, is always\nidempotent, and usually the identity function on the noun itself.</p>\n\n<p><code>|$</code> is a restricted form of <code>|*</code>. The use of <code>|$</code> over <code>|*</code> is one of style, as\neither could be used to make wet gates that are mold builders. The buc in <code>|$</code>\nis a hint that <code>|$</code> is closely related to buc runes, and thus <code>|$</code> should be\nused to make mold builders, while <code>|*</code> should be used for any other sort of wet\ngate. Unlike <code>|*</code>, the body of <code>|$</code> is parsed in pattern mode to a <code>$spec</code>.\nThus, the second argument of <code>|$</code> is frequently a buc rune. For further\ndiscussion of wet gates, see the entry for <a href=\"#-bartar\"><code>|*</code></a>.</p>\n\n<p>Like other single-arm cores, the arm for <code>|$</code> is named <code>$</code> and this can be used to\ndefine recursive structures. Note however that Hoon is evaluated eagerly, and so\ninfinite structures are not permitted.</p>\n\n<p>Proper style for <code>|$</code> is to enclose the first argument with brackets, even if it\nis only a single term. The interpeter will accept a single term without brackets\njust fine, but this style is for consistency with the fact that the first\nargument is a <code>lest</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo |$([a b] [b a])</p>\n</blockquote>\n\n<blockquote>\n  <p>=bar (foo [@ @tas])</p>\n</blockquote>\n\n<blockquote>\n  <p>(bar %cat 3)\n  [%cat 3]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "|_": "<p><code>|_</code> \"barcab\"</p>\n\n<p>Produce a <strong>door</strong> (a core with a sample).</p>\n\n<h4>Syntax</h4>\n\n<p>One fixed argument, then a variable number of <code>+</code>-family expressions.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |_  a=spec<p>  ++  b=term  c=hoon<p>  ++  d=term  e=hoon<p>       ...<p>  ++  f=term  g=hoon<p>  --<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p>Note: The <code>++</code> rune may be replaced with any other rune in the <code>+</code> family.</p>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brcb p=spec q=alas r=(map term tome)]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=|  a=spec\n|%\n++  b=term  c=hoon\n++  d=term  e=hoon\n       ...</p>\n\n<h2>++  f=term  g=hoon</h2>\n\n<p></pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>The product of a <code>|_</code> expression is a <strong>door</strong>, a core with one or more arms\nwhose payload includes a sample. That is, a door is a cell of <code>[battery [sample context]]</code>, where the <code>battery</code> contains one or more arms.</p>\n\n<p><code>a</code> defines the door sample type and usually includes a name assignment (e.g.,\n<code>n=@</code>). <code>a</code> is followed by a series of arm definitions, each of which begins\nwith a rune in the <code>+</code> family (most of <code>++</code>). There must be at least one arm,\nbut there may be arbitrarily many. Each arm must include a name (<code>b</code>, <code>d</code>, and\n<code>f</code> above), which is followed by the expression (<code>c</code>, <code>e</code>, and <code>g</code> above) that\ndefines the arm product.</p>\n\n<p>The context of the door is the subject of the <code>|_</code> expression.</p>\n\n<h4>Discussion</h4>\n\n<p>A door is the general case of a gate (function). A gate is a door with only one\narm, which has the name <code>$</code>.</p>\n\n<p>Calling a door is like calling a gate except the caller also needs to specify\nthe arm to be computed. So, for example, if you have some door <code>door</code> which\ncontains some arm <code>arm</code>, and you want to pass some argument (i.e., input value\n<code>arg</code>), you would call it with <code>~(arm door arg)</code>.</p>\n\n<p>Because gates are also doors, you can call them the same way. To call the gate\n<code>foo</code> as a door, instead of <code>(foo baz)</code> we would write <code>~($ foo baz)</code>. This is\nan irregular form for <code>%~($ foo baz)</code>,\n<a href=\"https://developers.urbit.org/reference/hoon/rune/cen#-censig\">%~</a>.</p>\n\n<h4>Examples</h4>\n\n<p>A trivial door:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=mol |_  a=@ud\n         ++  succ  +(a)\n         ++  prev  (dec a)\n         --</p>\n</blockquote>\n\n<blockquote>\n  <p>~(succ mol 1)\n  2</p>\n</blockquote>\n\n<blockquote>\n  <p>~(succ mol ~(succ mol ~(prev mol 5)))\n  6\n  </pre></code></p>\n</blockquote>\n\n<p>A more interesting door, from the kernel library:</p>\n\n<p><code><pre>\n++  ne\n  |_  tig=@\n  ++  d  (add tig '0')\n  ++  x  ?:((gte tig 10) (add tig 87) d)\n  ++  v  ?:((gte tig 10) (add tig 87) d)\n  ++  w  ?:(=(tig 63) '~' ?:(=(tig 62) '-' ?:((gte tig 36) (add tig 29) x)))\n  --\n</pre></code></p>\n\n<p>The <code>ne</code> door prints a digit in base 10, 16, 32 or 64:</p>\n\n<p></pre></code>\n~zod:dojo> <code>@t</code>~(x ne 12)\n'c'\n</pre></code></p>\n\n<hr />\n",
    "|:": "<p><code>|:</code> \"barcol\"</p>\n\n<p>Produce a gate with a custom sample.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |:  a<p>  b<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  |:(a b)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brcl p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p><code>a</code> is a Hoon expression whose product type defines which values the gate accepts, and it usually includes a name (e.g., <code>n=1</code>). The product of <code>a</code> also serves as the default value of the sample. <code>b</code> is a Hoon expression that determines the product value of the gate.</p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=+  a\n|.  b\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>Pick your own default value for the sample. Note that <code>a</code> is an ordinary\nexpression, not a type; <code>|:</code> doesn't bunt a sample as <a href=\"#-bartis\"><code>|=</code></a> does.</p>\n\n<p>This is useful if you want a gate to have a sample of a particular type, but you don't want the default value of the gate to be the default value of that type.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=add-ten |:(n=<code>@</code>2 (add n 10))</p>\n</blockquote>\n\n<blockquote>\n  <p>(add-ten 10)\n  20</p>\n</blockquote>\n\n<blockquote>\n  <p>(add-ten)\n  12\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "|%": "<p><code>|%</code> \"barcen\"</p>\n\n<p>Produce a core, <code>[battery payload]</code>.</p>\n\n<h4>Syntax</h4>\n\n<p>Argument: a variable number of <code>+</code>-family expressions.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |%<p>  ++  a=term  b=hoon<p>  ++  c=term  d=hoon<p>       ...<p>  ++  e=term  f=hoon<p>  --<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p>Note: The <code>++</code> rune may be replaced with any other rune in the <code>+</code> family.</p>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brcn p=(unit term) q=(map term tome)]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>The product of a <code>|%</code> expression is a dry core with one or more arms in the\nbattery.</p>\n\n<p>The <code>|%</code> rune is followed by a series of arm definitions, each of which begins\nwith a rune in the <code>+</code> family (most of <code>++</code>). There must be at least one arm,\nbut there may be arbitrarily many. Each arm must include a name (<code>a</code>, <code>c</code>, and\n<code>e</code> above), which is followed by the expression (<code>b</code>, <code>d</code>, and <code>f</code> above) that\ndefines the arm product.</p>\n\n<p>The core payload is the subject of the <code>|%</code> expression.</p>\n\n<h4>Discussion</h4>\n\n<p>A core is a cell of <code>[battery payload]</code>, where the <code>battery</code> is code and the\n<code>payload</code> is data. The <code>battery</code> is one or more arms. An arm is a computation\nthat takes the core itself as its subject.</p>\n\n<p>The <code>|%</code> rune is used to construct a core from a series of arm definitions. Each\narm definition in the expression begins with an arm rune (<code>++</code>, <code>+$</code>, or <code>+*</code>).\nThese arms make up the <code>battery</code>. The subject of the <code>|%</code> expression is used to\nmake the core's <code>payload</code>.</p>\n\n<p>A core is like an \"object\" in a conventional language, but its attributes\n(<em>arms</em>) are functions on the core, not the core and an argument. A \"method\" on\na core is an arm that produces a gate.</p>\n\n<h4>Examples</h4>\n\n<p>A trivial core:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo =+  x=58\n         |%\n         ++  n  (add 42 x)\n         ++  g  |=  b=@\n                (add b n)\n         --</p>\n</blockquote>\n\n<blockquote>\n  <p>n.foo\n  100</p>\n</blockquote>\n\n<blockquote>\n  <p>(g.foo 1)\n  101\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "|.": "<p><code>|.</code> \"bardot\"</p>\n\n<p>Produce a trap (a core with one arm <code>$</code>).</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |.  a<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  |.(a)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brdt p=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre></p>\n\n<h2>|%  ++  $  a=hoon</h2>\n\n<p></pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>|.</code> expression produces a core with a single arm, <code>$</code>. The core isn't\nexplicitly given a sample. <code>a</code> is a Hoon expression that defines the computation\nof the <code>$</code> arm.</p>\n\n<p>The payload of the core is the subject of the <code>|.</code> expression.</p>\n\n<h4>Discussion</h4>\n\n<p>A trap is generally used to defer a computation.</p>\n\n<h4>Examples</h4>\n\n<p>A trivial trap:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo |.(42)</p>\n</blockquote>\n\n<blockquote>\n  <p>$:foo\n  42</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo)\n  42\n  </pre></code></p>\n</blockquote>\n\n<p>A more interesting trap:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo =/  reps  10\n         =/  step  0\n         =/  outp  0\n         |.\n         ?:  =(step reps)\n           outp\n         $(outp (add outp 2), step +(step))</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo)\n  20\n  </pre></code></p>\n</blockquote>\n\n<p>Note that we can use <code>$()</code> to recurse back into the\ntrap, since it's a core with an <code>$</code> arm.</p>\n\n<blockquote>\n  <p><code>$(...)</code> expands to <code>%=($ ...)</code> (<a href=\"https://developers.urbit.org/reference/hoon/rune/cen#-centis\">\"centis\"</a>).</p>\n</blockquote>\n\n<hr />\n",
    "|^": "<p><code>|^</code> \"barket\"</p>\n\n<p>Produce a core whose battery includes a <code>$</code> arm and compute the latter.</p>\n\n<h4>Syntax</h4>\n\n<p>One fixed argument, then a variable number of <code>+</code>-family expressions.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |^  a=hoon<p>  ++  b=term  c=hoon<p>  ++  d=term  e=hoon<p>       ...<p>  ++  f=term  g=hoon<p>  --<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brkt p=hoon q=(map term tome)]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=&gt;  |%\n    ++  $  a=hoon\n    ++  b=term  c=hoon\n    ++  d=term  e=hoon\n           ...\n    ++  f=term  g=hoon\n    --\n$\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>|^</code> expression produces a multi-arm core whose battery includes a <code>$</code> arm,\nwhich is evaluated immediately. <code>a</code> is a Hoon expression that defines the\nproduct of the <code>$</code> arm. <code>a</code> is followed by a series of arm definitions for the\nrest of the core battery arms. There must be at least one arm other than the <code>$</code>\narm.</p>\n\n<h4>Discussion</h4>\n\n<p>The <code>|^</code> rune is useful when you define a multi-arm core in your code and a\nparticular arm in it is to be evaluated immediately.</p>\n\n<h4>Examples</h4>\n\n<p>A trivial example:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>|^\n    (add n g)\n    ++  n  42\n    ++  g  58\n    --\n  100\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "|-": "<p><code>|-</code> \"barhep\"</p>\n\n<p>Produce a trap (a core with one arm <code>$</code>) and evaluate it.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |-  a<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  |-(a)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brhp p=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=&lt;($ |.(a=hoon))\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>|-</code> expression produces a core with one arm named <code>$</code> and immediately\nevaluates <code>$</code>. <code>a</code> is a Hoon expression that determines what <code>$</code> evaluates to.</p>\n\n<h4>Discussion</h4>\n\n<p>The <code>|-</code> rune can be thought of as a 'recursion point' or a 'loop starting\npoint'. Since <code>|-</code> makes a <code>|.</code> (<a href=\"#-bardot\">\"bardot\"</a>, a core with one arm named\n<code>$</code>, we can recurse back into it with <code>$()</code>.</p>\n\n<blockquote>\n  <p><code>$(...)</code> expands to <code>%=($ ...)</code> (<a href=\"https://developers.urbit.org/reference/hoon/rune/cen#-centis\">\"centis\"</a>).</p>\n</blockquote>\n\n<h4>Examples</h4>\n\n<p>A trivial computation doesn't recurse:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>|-(42)\n  42\n  </pre></code></p>\n</blockquote>\n\n<p>The classic loop is a decrement:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo =/  a  42\n         =/  b  0\n         |-\n         ?:  =(a +(b))\n           b\n         $(b +(b))</p>\n</blockquote>\n\n<blockquote>\n  <p>foo\n  41\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "|~": "<p><code>|~</code> \"barsig\"</p>\n\n<p>Produce an iron gate.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |~  a<p>  b<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  |~(a b)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brsg p=spec q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n^|  |=(a b)\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>|~</code> expression produces an iron gate. <code>a</code> defines the sample, and <code>b</code> defines\nthe output value of the gate.</p>\n\n<h4>Discussion</h4>\n\n<p>See <a href=\"https://developers.urbit.org/reference/hoon/advanced\">this discussion of core variance models</a></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=&gt;  ~  ^+(|~(a=@ <em>@) |=(a=</em> *@))\n  &lt;1|usl {a/@ $~}&gt;\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "|*": "<p><code>|*</code> \"bartar\"</p>\n\n<p>Produce a wet gate (one-armed core with sample).</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |*  a  b<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  |*(a b)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brtr p=spec q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=|  a\n|@\n++  $</p>\n\n<h2>  b</h2>\n\n<p></pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>|*</code> expression produces a wet gate. <code>a</code> defines the gate's sample, and <code>b</code> is\na Hoon expression that determines the output value of the gate.</p>\n\n<h4>Discussion</h4>\n\n<p>In a normal (dry) gate, your argument is converted into the\nsample type. In a generic (wet) gate, your argument type\npasses through the function, rather as if it were a macro (there\nis still only one copy of the code, however).</p>\n\n<p>Genericity is a powerful and dangerous tool. Use wet gates only if\nyou know what you're doing.</p>\n\n<p>Just as with a <a href=\"#-bartis\">gate</a>, we can recurse back into a wet gate\nwith <code>$()</code>.</p>\n\n<blockquote>\n  <p><code>$(...)</code> expands to <code>%=($ ...)</code> (<a href=\"https://developers.urbit.org/reference/hoon/rune/cen#-centis\">\"centis\"</a>).</p>\n</blockquote>\n\n<p><code>|*</code> can be used to make wet gates that produce structures, but this usage is\ndiscouraged in favor of <code>|$</code>.</p>\n\n<h4>Examples</h4>\n\n<p>Wet and dry gates in a nutshell:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo |=([a=* b=*] [b a])</p>\n</blockquote>\n\n<blockquote>\n  <p>=bar |<em>([a=</em> b=*] [b a])</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo %cat %dog)\n  [6.778.724 7.627.107]</p>\n</blockquote>\n\n<blockquote>\n  <p>(bar %cat %dog)\n  [%dog %cat]\n  </pre></code></p>\n</blockquote>\n\n<p>The dry gate does not preserve the type of <code>a</code> and <code>b</code>; the wet\ngate does.</p>\n\n<hr />\n",
    "|=": "<p><code>|=</code> \"bartis\"</p>\n\n<p>Produce a gate (a one-armed core with a sample).</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |=  a<p>  b<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  |=(a b)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brts p=spec q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=+  ^~(*a=spec)</p>\n\n<h2>|%  ++  $  b=hoon</h2>\n\n<p></pre></code></p>\n\n<h4>Definition</h4>\n\n<p>The product of a <code>|=</code> expression is a dry <strong>gate</strong>, i.e., a Hoon function.</p>\n\n<p><code>p</code> defines the gate sample type -- i.e., the input value type -- and usually\nincludes a sample name assignment (e.g., <code>a=@</code>). <code>q</code> is an expression that\ndetermines the output value of the gate.</p>\n\n<h4>Discussion</h4>\n\n<p>Dry gates are used for the vast majority of ordinary functions in Hoon.</p>\n\n<p>A gate is a core with one arm named <code>$</code>, so we can recurse back into it with <code>$()</code>.</p>\n\n<blockquote>\n  <p><code>$(...)</code> expands to <code>%=($ ...)</code> (<a href=\"https://developers.urbit.org/reference/hoon/rune/cen#-centis\">\"centis\"</a>).</p>\n</blockquote>\n\n<h4>Examples</h4>\n\n<p>A trivial gate:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo |=(a=@ +(a))</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo 20)\n  21\n  </pre></code></p>\n</blockquote>\n\n<p>A slightly less trivial gate:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo |=  [a=@ b=@]\n         (add a b)</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo 30 400)\n  430\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "|@": "<p><code>|@</code> \"barpat\"</p>\n\n<p>Produce a 'wet' core <code>[battery payload]</code>.</p>\n\n<h4>Syntax</h4>\n\n<p>Arguments: a variable number of <code>+</code>-family expressions.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |@<p>  ++  a=term  b=hoon<p>  ++  c=term  d=hoon<p>       ...<p>  ++  e=term  f=hoon<p>  --<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p>Note: The <code>++</code> rune may be replaced with any other rune in the <code>+</code> family.</p>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brpt p=(unit term) q=(map term tome)]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>|@</code> expression produces a 'wet' core whose payload is the expression's\nsubject. The various arms in the battery are each named (<code>a</code>, <code>c</code>, and <code>e</code>\nabove) and defined explicitly with a Hoon expression (with <code>b</code>, <code>d</code>, and <code>f</code>\nabove).</p>\n\n<h4>Discussion</h4>\n\n<p>The <code>|@</code> rune is just like the <code>|%</code> rune except that instead of producing a\n'dry' core, it produces a 'wet' one. This allows for type polymorphism of its\narms, using 'genericity'. See <a href=\"https://developers.urbit.org/reference/hoon/advanced\">Advanced types</a>.</p>\n\n<hr />\n",
    "|?": "<p><code>|?</code> \"barwut\"</p>\n\n<p>Produce a lead trap.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  |?  a<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  |?(a)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%brwt p=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n^?  |.  a\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>|?</code> expression produces a lead trap (i.e., a lead core with one arm named\n<code>$</code>). <code>a</code> is a Hoon expression that defines what the <code>$</code> arm does.</p>\n\n<h4>Discussion</h4>\n\n<p>See this <a href=\"https://developers.urbit.org/reference/hoon/advanced\">discussion of the core variance model</a>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=&gt;  ~  ^+  |?(%a)  |.(%a)\n  &lt;1?pqz $~&gt;</p>\n</blockquote>\n\n<blockquote>\n  <p>=&gt;  ~  ^+  |?(%a)  |.(%b)\n  nest-fail\n  </pre></code></p>\n</blockquote>\n",
    "$|": "<p><code>$|</code> \"bucbar\"</p>\n\n<p>Structure that satisfies a validator.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $|  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $|(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bcbr p=spec q=hoon]\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>$|</code> is used for validation of values at a finer level than that of types.\nRecall that a given value of <code>type</code> can be equivalently defined by more than one\n<code>spec</code>. For performance reasons, it may be beneficial to restrict oneself to\nvalues of a given type that adhere to an abstract syntax tree specified by some\nsubset of those <code>spec</code>s that may be used to define a given type.</p>\n\n<p><code>$|</code> takes two arguments: a structure <code>a</code> and a gate <code>b</code> that produces a <code>flag</code>\nthat is used to validate values produced by the mold generated by <code>a</code> at\nruntime. <code>$|(a b)</code> is a gate that takes in a noun <code>x</code> and first pins the product\nof clamming <code>a</code> with <code>x</code>, call this <code>foo</code>. Then it calls <code>b</code> on <code>foo</code>. It\nasserts that the product of <code>(b foo)</code> is <code>&amp;</code>, and then produces <code>foo</code>. This is\nequivalent to the following (which is not how <code>$|</code> is actually defined but has\nthe same behavior):</p>\n\n<p><code><pre>\n|=  x=*\n=/  foo  ;;(a x)\n?>  (b foo)\nfoo\n</pre></code></p>\n\n<p>For example, the elements of a <code>set</code> are treated as being unordered, but the\nvalues will necessarily possess an order by where they are in the memory. Thus\nif every <code>set</code> is stored using the same order scheme then faster algorithms\ninvolving <code>set</code>s may be written. Furthermore, if you just place elements in the\n<code>set</code> randomly, it may be mistreated by algorithms already in place that are\nexpecting a certain order. This is not the same thing as casting - it is forcing\na type to have a more specific set of values than its mold would suggest. This\nrune should rarely be used, but it is extremely important when it is.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo $|  (list @)\n         |=(a=(list) (lth (lent a) 4))\n  </pre></code></p>\n</blockquote>\n\n<p>This creates a structure <code>foo</code> whose values are <code>list</code>s with length less than 4.</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(foo ~[1 2 3])\n  ~[1 2 3]</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo ~[1 2 3 4])\n  ford: %ride failed to execute:\n  </pre></code></p>\n</blockquote>\n\n<p>The definition of <code>+set</code> in <code>hoon.hoon</code> is the following:</p>\n\n<p><code><pre>\n++  set\n  |$  [item]\n  $|  (tree item)\n  |=(a=(tree) ?:(=(~ a) &amp; ~(apt in a)))\n</pre></code></p>\n\n<p>Here <a href=\"https://developers.urbit.org/reference/hoon/rune/bar#-barbuc\"><code>|$</code></a> is used to define a mold\nbuilder that takes in a mold (given the face <code>item</code>) and creates a structure\nconsisting of a <code>tree</code> of <code>item</code>s with <code>$|</code> that is validated with the gate\n<code>|=(a=(tree) ?:(=(~ a) &amp; ~(apt in a)))</code>. <code>in</code> is a door in <code>hoon.hoon</code> with\nfunctions for handling <code>set</code>s, and <code>apt</code> is an arm in that door that checks that\nthe values in the <code>tree</code> are arranged in the particular way that <code>set</code>s are\narranged in Hoon, namely 'ascending <code>+mug</code> hash order'.</p>\n\n<hr />\n",
    "$_": "<p><code>$_</code> \"buccab\"</p>\n\n<p>Structure that normalizes to an example.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $_  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $_(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    _p<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bccb p=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n|=(* p)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>$_</code> discards the sample it's supposedly normalizing and produces its\n<strong>example</strong> instead.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo $_([%foobaz %moobaz])</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo %foo %baz)\n  [%foobaz %moobaz]</p>\n</blockquote>\n\n<blockquote>\n  <p><code>foo</code>[%foobaz %moobaz]\n  [%foobaz %moobaz]</p>\n</blockquote>\n\n<blockquote>\n  <p>$:foo\n  [%foobaz %moobaz]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$%": "<p><code>$%</code> \"buccen\"</p>\n\n<p>Structure which recognizes a union tagged by head atom.</p>\n\n<h4>Syntax</h4>\n\n<p>A variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $%  [%p1 ...]<p>      [%p2 ...]<p>      [%p3 ...]<p>      [%pn ...]<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $%([%p1 ...] [%p2 ...] [%p3 ...] [%pn ...])<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p>Each item may be an atom or (more commonly) a cell. The atom or head of the cell\n<em>must</em> be a constant (<code>%foo</code>, <code>%1</code>, <code>%.y</code>, etc).</p>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bccn p=(list spec)]\n</pre></code></p>\n\n<h4>Defaults to</h4>\n\n<p>The default of the last item <code>i</code> in <code>p</code>. Crashes if <code>p</code> is empty.</p>\n\n<h4>Discussion</h4>\n\n<p>A <code>$%</code> is a tagged union, a common data model.</p>\n\n<p>Make sure the last item in your <code>$%</code> terminates, or the default will\nbe an infinite loop! Alteratively, you can use <code>$~</code> to define a custom\ntype default value.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo $%([%foo p=@ud q=@ud] [%baz p=@ud])</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo [%foo 4 2])\n  [%foo p=4 q=2]</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo [%baz 37])\n  [%baz p=37]</p>\n</blockquote>\n\n<blockquote>\n  <p>$:foo\n  [%baz p=0]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$:": "<p><code>$:</code> \"buccol\"</p>\n\n<p>Form a cell type.</p>\n\n<h4>Syntax</h4>\n\n<p>A variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $:  p1<p>      p2<p>      p3<p>      pn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $:(p1 p2 p3 pn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular (noun mode)</td>\n  <td style=\"text-align:center;\"><pre>  ,[p1 p2 p3 pn]<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular (structure mode)</td>\n  <td style=\"text-align:center;\"><pre>    [p1 p2 p3 pn]<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bccl p=(list spec)]\n</pre></code></p>\n\n<h4>Normalizes to</h4>\n\n<p>The tuple the length of <code>p</code>, normalizing each item.</p>\n\n<h4>Defaults to</h4>\n\n<p>The tuple the length of <code>p</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo $:(p=@ud q=@tas)</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo 33 %foo)\n  [p=33 q=%foo]</p>\n</blockquote>\n\n<blockquote>\n  <p><code>foo</code>[33 %foo]\n  [p=33 q=%foo]</p>\n</blockquote>\n\n<blockquote>\n  <p>$:foo\n  [p=0 q=%$]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$<": "<p><code>$&lt;</code> \"bucgal\"</p>\n\n<p>Filters a pre-existing mold to obtain a mold that excludes a particular\nstructure.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $&lt;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $&lt;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bcgl p=spec q=spec]\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>This can be used to obtain type(s) from a list of types <code>q</code> that do not satisfy a\nrequirement given by <code>p</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo $%([%bar p=@ud q=@ud] [%baz p=@ud])</p>\n</blockquote>\n\n<blockquote>\n  <p>=m $&lt;(%bar foo)</p>\n</blockquote>\n\n<blockquote>\n  <p>(m [%bar 2 4])\n  ford: %ride failed to execute:</p>\n</blockquote>\n\n<blockquote>\n  <p>(m [%baz 2])\n  [%baz p=2]</p>\n</blockquote>\n\n<blockquote>\n  <p>;;($&lt;(%foo [@tas *]) [%foo 1])\n  ford: %ride failed to execute:</p>\n</blockquote>\n\n<blockquote>\n  <p>;;($&lt;(%foo [@tas *]) [%bar 1])\n  [%bar 1]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$>": "<p><code>$&gt;</code> \"bucgar\"</p>\n\n<p>Filters a mold to obtain a new mold matching a particular structure.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $&gt;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $&gt;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bcgr p=spec q=spec]\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>This can be used to obtain type(s) from a list of types <code>q</code> that satisfy a\nrequirement given by <code>p</code>.</p>\n\n<h4>Examples</h4>\n\n<p>Examples with <code>$%</code>:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo $%([%bar p=@ud q=@ud] [%baz p=@ud])</p>\n</blockquote>\n\n<blockquote>\n  <p>=m $&gt;(%bar foo)</p>\n</blockquote>\n\n<blockquote>\n  <p>(m [%bar 2 4])\n  [%bar p=2 q=4]</p>\n</blockquote>\n\n<blockquote>\n  <p>(m [%baz 2])\n  ford: %ride failed to execute:\n  </pre></code></p>\n</blockquote>\n\n<p>Examples with <code>;;</code>:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>;;([@tas *] [%foo 1])\n  [%foo 1]</p>\n</blockquote>\n\n<blockquote>\n  <p>;;([@tas *] [%bar 1])\n  [%bar 1]</p>\n</blockquote>\n\n<blockquote>\n  <p>;;($&gt;(%foo [@tas *]) [%foo 1])\n  [%foo 1]</p>\n</blockquote>\n\n<blockquote>\n  <p>;;($&gt;(%foo [@tas *]) [%bar 1])\n  ford: %ride failed to execute:\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$-": "<p><code>$-</code> \"buchep\"</p>\n\n<p>Structure that normalizes to an example gate.</p>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bchp p=spec q=spec]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n$_  ^|\n|=(p $:q)\n</pre></code></p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $-  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $-(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code>p</code> is the type the gate takes and <code>q</code> is the type the gate produces.</p>\n\n<h4>Discussion</h4>\n\n<p>Since a <code>$-</code> reduces to a <a href=\"#_-buccab\"><code>$_</code></a>, it is not useful for normalizing, just for typechecking. In particular, the existence of <code>$-</code>s does <strong>not</strong> let us send gates or other cores over the network!</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo $-(%foo %baz)</p>\n</blockquote>\n\n<blockquote>\n  <p>($:foo %foo)\n  %baz\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$^": "<p><code>$^</code> \"bucket\"</p>\n\n<p>Structure which normalizes a union tagged by head depth (cell).</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $^  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $^(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bckt p=spec q=spec]\n</pre></code></p>\n\n<h4>Normalizes to</h4>\n\n<p>Default, if the sample is an atom; <code>p</code>, if the head of the sample\nis an atom; <code>q</code> otherwise.</p>\n\n<h4>Defaults to</h4>\n\n<p>The default of <code>p</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=a $%([%foo p=@ud q=@ud] [%baz p=@ud])</p>\n</blockquote>\n\n<blockquote>\n  <p>=b $^([a a] a)</p>\n</blockquote>\n\n<blockquote>\n  <p>(b [[%baz 33] [%foo 19 22]])\n  [[%baz p=33] [%foo p=19 q=22]]</p>\n</blockquote>\n\n<blockquote>\n  <p>(b [%foo 19 22])\n  [%foo p=19 q=22]</p>\n</blockquote>\n\n<blockquote>\n  <p>$:b\n  [%baz p=0]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$+": "<p><code>$+</code> \"buclus\"</p>\n\n<p>Specify a shorthand type name for use in prettyprinting.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $+  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $+(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bcls p=stud q=spec]\n</pre></code></p>\n\n<!--\n#### Normalizes to\n\nDefault, if the sample is an atom; `p`, if the head of the sample\nis an atom; `q` otherwise.\n\n#### Defaults to\n\nThe default of `p`.\n-->\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=/  my-type  $+(my-alias [@ @])</p>\n</blockquote>\n\n<blockquote>\n  <p>-:!>(*my-type)</p>\n  \n  <h1>t/#my-alias</h1>\n</blockquote>\n\n<p></pre></code></p>\n\n<hr />\n",
    "$&": "<p><code>$&amp;</code> \"bucpam\"</p>\n\n<p>Repair a value of a tagged union type.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $&amp;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $&amp;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code><pre>\n$&amp;(combined-mold=spec normalizing-gate=hoon)\n</pre></code></p>\n\n<p>Here <code>combined-mold</code> is a tagged union type (typically made with <code>$%</code>) and\n<code>normalizing-gate</code> is a gate which accepts values of <code>combined-mold</code> and\nnormalizes them to be of one particular type in <code>combined-mold</code>.</p>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bcpm p=spec q=hoon]\n</pre></code></p>\n\n<h4>Normalizes to</h4>\n\n<p>The product of the normalizing gate and sample.</p>\n\n<h4>Defaults to</h4>\n\n<p>The default of the last type listed in <code>p</code>, normalized with the normalizing gate.</p>\n\n<h4>Discussion</h4>\n\n<p>This rune is used to \"upgrade\" or \"repair\" values of a structure, typically from\nan old version to a new version. For example, this may happen when migrating\nstate after updating an app.</p>\n\n<h4>Examples</h4>\n\n<p><code><pre>\n+$  old  [%0 @]\n+$  new  [%1 ^]\n+$  combined  $%(old new)\n+$  adapting  $&amp;(combined |=(?-(-.a %0 [%1 1 +.a], %1 a)))\n</pre></code></p>\n\n<p>Here <code>adapting</code> is a structure that bunts to <code>[%1 ^]</code> but also normalizes from\n<code>[%0 @]</code> if called on such a noun.</p>\n\n<hr />\n",
    "$~": "<p><code>$~</code> \"bucsig\"</p>\n\n<p>Define a custom type default value.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $~  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $~(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code>p</code> defines the default value, and <code>q</code> defines everything else about the\nstructure.</p>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bcsg p=hoon q=spec]\n</pre></code></p>\n\n<h4>Product</h4>\n\n<p>Creates a structure (custom type) just like <code>q</code>, except its default value is <code>p</code>.</p>\n\n<h4>Defaults to</h4>\n\n<p>The product of <code>p</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>You should make sure that the product type of <code>p</code> nests under <code>q</code>. You can check\nthe default value of some structure (custom type) <code>r</code> with <code>*r</code>. (See the <a href=\"https://developers.urbit.org/reference/hoon/rune/ket#-kettar\"><code>^*</code>\nrune</a>.)</p>\n\n<p>Do not confuse the <code>$~</code> rune with the constant type for null, <code>$~</code>. (The latter\nuses older Hoon syntax that is still accepted. Preferably it would be <code>%~</code>.)</p>\n\n<h4>Examples</h4>\n\n<p>First, let's define a type without using <code>$~</code>:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=b $@(@tas $%([%two *] [%three *]))</p>\n</blockquote>\n\n<blockquote>\n  <p><code>b</code>%hello\n  %hello</p>\n</blockquote>\n\n<blockquote>\n  <p><code>b</code>[%two %hello]\n  [%two 478.560.413.032]</p>\n</blockquote>\n\n<blockquote>\n  <p>*b</p>\n</blockquote>\n\n<p>%$</p>\n\n<blockquote>\n  <p>*@tas\n  %$\n  </pre></code></p>\n</blockquote>\n\n<p>Using <code>$~</code>:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=c $~(%default-value $@(@tas $%([%two *] [%three *])))</p>\n</blockquote>\n\n<blockquote>\n  <p><code>c</code>%hello\n  %hello</p>\n</blockquote>\n\n<blockquote>\n  <p><code>c</code>[%two %hello]\n  [%two 478.560.413.032]</p>\n</blockquote>\n\n<blockquote>\n  <p>*c\n  %default-value\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$@": "<p><code>$@</code> \"bucpat\"</p>\n\n<p>Structure which normalizes a union tagged by head depth (atom).</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $@  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $@(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bcpt p=spec q=spec]\n</pre></code></p>\n\n<h4>Normalizes to</h4>\n\n<p><code>p</code>, if the sample is an atom; <code>q</code>, if the sample is a cell.</p>\n\n<h4>Defaults to</h4>\n\n<p>The default of <code>p</code>.</p>\n\n<h4>Produces</h4>\n\n<p>A structure which applies <code>p</code> if its sample is an atom, <code>q</code> if its sample is a\ncell.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=a $@(%foo $:(p=%baz q=@ud))</p>\n</blockquote>\n\n<blockquote>\n  <p>(a %foo)\n  %foo</p>\n</blockquote>\n\n<blockquote>\n  <p><code>a</code>[%baz 99]\n  [p=%baz q=99]</p>\n</blockquote>\n\n<blockquote>\n  <p>$:a\n  %foo\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$=": "<p><code>$=</code> \"buctis\"</p>\n\n<p>Structure which wraps a face around another structure.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $=  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $=(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    p=q<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bcts p=skin q=spec]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n|=  *\n^=(p %-(q +6))\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>Note that the Hoon compiler is at least slightly clever about\ncompiling structures, and almost never has to actually put in a gate\nlayer (as seen in the expansion above) to apply a <code>$=</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=a $=(p %foo)</p>\n</blockquote>\n\n<blockquote>\n  <p>(a %foo)\n  p=%foo</p>\n</blockquote>\n\n<blockquote>\n  <p>(a %baz)\n  ford: %ride failed to execute:\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "$?": "<p><code>$?</code> \"bucwut\"</p>\n\n<p>Form a type from a union of other types.</p>\n\n<h4>Syntax</h4>\n\n<p>Variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  $?  p1<p>      p2<p>      p3<p>      pn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  $?(p1 p2 p3 pn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    ?(p1 p2 p3 pn)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%bcwt p=(list spec)]\n</pre></code></p>\n\n<h4>Normalizes to</h4>\n\n<p>The last item in <code>p</code> which normalizes the sample to itself.</p>\n\n<p>Void, if <code>p</code> is empty.</p>\n\n<h4>Defaults to</h4>\n\n<p>The last item in <code>p</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>For a union of atoms, a <code>$?</code> is fine. For more complex nouns, always try to use\na <a href=\"#-buccen\"><code>$%</code></a>, <a href=\"#-bucpat\"><code>$@</code></a> or <a href=\"#-bucket\"><code>$^</code></a>, at least if you expect\nyour structure to be used as a normalizer.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=a ?(%foo %baz %baz)</p>\n</blockquote>\n\n<blockquote>\n  <p>(a %baz)\n  %baz</p>\n</blockquote>\n\n<blockquote>\n  <p>(a [37 45])\n  ford: %ride failed to execute:</p>\n</blockquote>\n\n<blockquote>\n  <p>$:a\n  %baz\n  </pre></code></p>\n</blockquote>\n",
    "%_": "<p><code>%_</code> \"cencab\"</p>\n\n<p>Resolve a wing with changes, preserving type.</p>\n\n<h4>Syntax</h4>\n\n<p>One fixed argument, then a variable number of pairs.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall style #1</td>\n  <td style=\"text-align:center;\"><pre>  %_  a=wing<p>    b=wing  c=hoon<p>    d=wing  e=hoon<p>    f=wing  g=hoon<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Tall style #2</td>\n  <td style=\"text-align:center;\"><pre>  %_    a=wing<p>      b=wing<p>    c=hoon<p>  ::<p>      d=wing<p>    e=hoon<p>  ::<p>      f=wing<p>    g=hoon<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  %_(a=wing b=wing c=hoon, d=wing e=hoon, ...)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%cncb p=wing q=(list (pair wing hoon))]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n^+(a %=(a b c, d e, ...))\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>%_</code> expression resolves to the value of the subject at wing <code>a</code>, but modified\naccording to a series of changes: <code>b</code> is replaced with the product of <code>c</code>, <code>d</code>\nwith the product of <code>e</code>, and so on. At compile time a type check is performed to\nensure that the resulting value is of the same type as <code>a</code>.</p>\n\n<h4>Discussion</h4>\n\n<p><code>%_</code> is different from <code>%=</code> because <code>%=</code> can change the type of a wing with\nmutations. <code>%_</code> preserves the wing type.</p>\n\n<p>See <a href=\"https://developers.urbit.org/reference/hoon/limbs/\">how wings are resolved</a>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo [p=42 q=6]</p>\n</blockquote>\n\n<blockquote>\n  <p>foo(p %baz)\n  [p=%baz q=6]</p>\n</blockquote>\n\n<blockquote>\n  <p>foo(p [55 99])\n  [p=[55 99] q=6]</p>\n</blockquote>\n\n<blockquote>\n  <p>%_(foo p %baz)\n  [p=7.496.034 99]</p>\n</blockquote>\n\n<blockquote>\n  <p>%_(foo p [55 99])\n  ! nest-fail\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "%:": "<p><code>%:</code> \"cencol\"</p>\n\n<p>Call a gate with many arguments.</p>\n\n<h4>Syntax</h4>\n\n<p>One fixed argument, then a variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  %:  a=hoon<p>    b=hoon<p>    c=hoon<p>     ...<p>    d=hoon<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  %:(a b c d)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    (a b c d)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%cncl p=hoon q=(list hoon)]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>%:</code> expression calls a gate with many arguments. <code>a</code> is the gate to be\ncalled, and <code>b</code> through <code>d</code> are the arguments. If there is only one\nsubexpression after <code>a</code>, its product is the sample. Otherwise, a single argument\nis constructed by evaluating all of <code>b</code> through <code>d</code> -- however many\nsubexpressions there are -- and putting the result in a cell: <code>[b c ... d]</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>When <code>%:</code> is used in tall-form syntax, the series of expressions after <code>p</code> must be terminated with <code>==</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>%:  add  22  33  ==\n  55</p>\n</blockquote>\n\n<blockquote>\n  <p>=adder |=  a=*\n           =+  c=0\n           |-\n           ?@  a  (add a c)\n           ?^  -.a  !!\n           $(c (add -.a c), a +.a)</p>\n</blockquote>\n\n<blockquote>\n  <p>%:  adder  22  33  44  ==\n  99</p>\n</blockquote>\n\n<blockquote>\n  <p>%:  adder  22  33  44  55  ==\n  154</p>\n</blockquote>\n\n<blockquote>\n  <p>%:(adder 22 33 44)\n  99</p>\n</blockquote>\n\n<blockquote>\n  <p>(adder 22 33 44)\n  99\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "%.": "<p><code>%.</code> \"cendot\"</p>\n\n<p>Call a gate (function), inverted.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  %.  a  b<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  %.(a b)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%cndt p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>The <code>%.</code> rune is for evaluating the <code>$</code> arm of a gate, i.e., calling a function.\n<code>a</code> is for the desired sample value (i.e., input value), and <code>b</code> is the gate.</p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n%-(b=hoon a=hoon)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>%.</code> is just like <code>%-</code>, but with its subexpressions reversed; the argument comes\nfirst, and then the gate.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=add-triple |=([a=@ b=@ c=@] :(add a b c))</p>\n</blockquote>\n\n<blockquote>\n  <p>%.([1 2 3] add-triple)\n  6\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "%-": "<p><code>%-</code> \"cenhep\" {% #-cenhep %}</p>\n\n<p>Call a gate (function).</p>\n\n<h4>Syntax</h4>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  %-  a<p>  b<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  %-(a b)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    (a b)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%cnhp p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>This rune is for evaluating the <code>$</code> arm of a gate, i.e., calling a gate as a\nfunction. <code>a</code> is the gate, and <code>b</code> is the desired sample value (i.e., input\nvalue) for the gate.</p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n%~($ a b)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>%-</code> is used to call a function; <code>a</code> is the function\n(<a href=\"https://developers.urbit.org/reference/hoon/rune/bar#-bartis\"><code>gate</code></a>, <code>q</code> the argument. <code>%-</code> is a\nspecial case of <a href=\"#-censig\"><code>%~</code> (\"censig\")</a>, and a gate is a special case of a\n<a href=\"https://developers.urbit.org/reference/hoon/rune/bar#_-barcab\">door</a>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=add-triple |=([a=@ b=@ c=@] :(add a b c))</p>\n</blockquote>\n\n<blockquote>\n  <p>(add-triple 1 2 3)\n  6</p>\n</blockquote>\n\n<blockquote>\n  <p>%-(add-triple [1 2 3])\n  6\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "%^": "<p><code>%^</code> \"cenket\"</p>\n\n<p>Call gate with triple sample.</p>\n\n<h4>Syntax</h4>\n\n<p>Four arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  %^    a<p>      b<p>    c<p>  d<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  %^(a b c d)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    (a b c d)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%cnkt p=hoon q=hoon r=hoon s=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n%-(a=hoon [b=hoon c=hoon d=hoon])\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=add-triple |=([a=@ b=@ c=@] :(add a b c))</p>\n</blockquote>\n\n<blockquote>\n  <p>%^(add-triple 1 2 3)\n  6\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "%+": "<p><code>%+</code> \"cenlus\"</p>\n\n<p>Call gate with a cell sample.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  %+  a<p>    b<p>  c<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  %+(a b c)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    (a b c)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%cnls p=hoon q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>%+</code> expression is for calling a gate with a cell sample. <code>a</code> is the gate to\nbe called, <code>b</code> is for the head of the sample, and <code>c</code> is for the sample tail.</p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n%-(a=hoon [b=hoon c=hoon])\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=add-triple |=([a=@ b=@ c=@] :(add a b c))</p>\n</blockquote>\n\n<blockquote>\n  <p>%+(add-triple 1 [2 3])\n  6\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "%~": "<p><code>%~</code> \"censig\"</p>\n\n<p>Evaluate an arm in a door.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  %~  p=wing  q=hoon<p>  r=hoon<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  %~(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    ~(p q r1 r2 rn)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<p>In the irregular form, <code>r</code> may be split into multiple parts. Multiple parts of\n<code>r</code> will be formed into a cell.</p>\n\n<h4>Semantics</h4>\n\n<p>A <code>%~</code> expression evaluates the arm of a door (i.e., a core with a sample). <code>p</code>\nis a wing that resolves to the arm from within the door in question. <code>q</code> is the\ndoor itself. <code>r</code> is the sample of the door.</p>\n\n<h4>Discussion</h4>\n\n<p><code>%~</code> is the general case of a function call, <code>%-</code>. In both, we replace the sample (<code>+6</code>) of a core. In <code>%-</code> the core is a gate and the <code>$</code> arm is evaluated. In <code>%~</code> the core is a door and any arm may be evaluated. You must identify the arm to be run: <code>%~(arm door arg)</code>.</p>\n\n<p>Note also that <code>p</code> is a wing and can therefore be <code>.</code>, as in <code>~(. door\nsample)</code>. This little idiom lets you load your sample into the door once\ninstead of over and over.</p>\n\n<p>See also <a href=\"https://developers.urbit.org/reference/hoon/rune/bar#_-barcab\"><code>|_</code></a>.</p>\n\n<h4>Examples</h4>\n\n</pre></code>\n<blockquote>\n\n<p><p>=mycore |_  a=@\n            ++  plus-two  (add 2 a)\n            ++  double  (mul 2 a)\n            ++  mul-by\n              |=  b=@\n              (mul a b)\n            --</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p>~(plus-two mycore 10)\n  12</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p>~(double mycore 10)\n  20</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p>=tencore ~(. mycore 10)\n   (mul-by:tencore 5)\n  50\n  </pre></code></p>\n</blockquote></p>\n\n<hr />\n",
    "%*": "<p><code>%*</code> \"centar\"</p>\n\n<p>Evaluate an expression, then resolve a wing with changes.</p>\n\n<h4>Syntax</h4>\n\n<p>Two fixed arguments, then a variable number of pairs.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall style #1</td>\n  <td style=\"text-align:center;\"><pre>  %*  a=wing  b=hoon<p>    c=wing  d=hoon<p>    e=wing  f=hoon<p>         ...<p>    g=wing  h=hoon<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Tall style #2</td>\n  <td style=\"text-align:center;\"><pre>  %*    a=wing  b=hoon<p>      c=wing<p>    d=hoon<p>  ::<p>      e=wing<p>    f=hoon<p>  ::<p>      g=wing<p>    h=hoon<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  %*(a b c d, e f, g h)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%cntr p=wing q=hoon r=(list (pair wing hoon))]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>%*</code> expression evaluates some arbitrary Hoon expression, <code>b</code>, and then\nresolves a wing of that result, with changes. <code>a</code> is the wing to be resolved,\nand one or more changes is defined by the subexpressions after <code>b</code>.</p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=+  b=hoon\n%=  a=wing\n  c=wing  d=hoon\n  e=wing  f=hoon\n       ...</p>\n\n<h1>  g=wing  h=hoon</h1>\n\n<p></pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>%*($ add a 2, b 3)\n  5</p>\n</blockquote>\n\n<blockquote>\n  <p>%*(b [a=[12 14] b=[c=12 d=44]] c 11)\n  [c=11 d=44]</p>\n</blockquote>\n\n<blockquote>\n  <p>%*(b [a=[12 14] b=[c=12 d=44]] c 11, d 33)\n  [c=11 d=33]</p>\n</blockquote>\n\n<blockquote>\n  <p>=foo [a=1 b=2 c=3 d=4]</p>\n</blockquote>\n\n<blockquote>\n  <p>%*(+ foo c %hello, d %world)\n  [b=2 c=%hello d=%world]</p>\n</blockquote>\n\n<blockquote>\n  <p>=+(foo=[a=1 b=2 c=3] foo(b 7, c 10))\n  [a=1 b=7 c=10]</p>\n</blockquote>\n\n<blockquote>\n  <p>%*(foo [foo=[a=1 b=2 c=3]] b 7, c 10)\n  [a=1 b=7 c=10]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "%=": "<p><code>%=</code> \"centis\"</p>\n\n<p>Resolve a wing with changes.</p>\n\n<h4>Syntax</h4>\n\n<p>One fixed argument, then a variable number of pairs.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall style #1</td>\n  <td style=\"text-align:center;\"><pre>  %=  a=wing<p>    b=wing  c=hoon<p>    d=wing  e=hoon<p>         ...<p>    f=wing  g=hoon<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Tall style #2</td>\n  <td style=\"text-align:center;\"><pre>  %=    a=wing<p>      b=wing<p>    c=hoon<p>  ::<p>      d=wing<p>    e=hoon<p>  ::<p>      f=wing<p>    g=hoon<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  %=(a b c, d e, f g)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    a(b c, d e, f g)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%cnts p=wing q=(list (pair wing hoon))]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>%=</code> expression resolves a wing of the subject, but with changes made.</p>\n\n<p>If <code>a</code> resolves to a leg, a series of changes are made to wings of that leg\n(<code>b</code>, <code>d</code>, and <code>f</code> above are replaced with the respective products of <code>c</code>, <code>e</code>,\nand <code>g</code> above). The modified leg is returned.</p>\n\n<p>If <code>a</code> resolves to an arm, a series of changes are made to wings of the parent\ncore of that arm. (Again, <code>b</code>, <code>d</code>, and <code>f</code> are replaced with the respective\nproducts of <code>c</code>, <code>e</code>, and <code>g</code>.) The arm is computed with the modified core as\nthe subject, and the product is returned.</p>\n\n<h4>Discussion</h4>\n\n<p>Note that <code>a</code> is a wing, not just any expression. Knowing that a function call\n<code>(foo baz)</code> involves evaluating <code>foo</code>, replacing its sample at slot <code>+6</code> with\n<code>baz</code>, and then resolving to the <code>$</code> limb, you might think <code>(foo baz)</code> would\nmean <code>%=(foo +6 baz)</code>.</p>\n\n<p>But it's actually <code>=+(foo =&gt;(%=(+2 +6 baz:+3) $))</code>. Even if <code>foo</code> is a wing, we\nwould just be mutating <code>+6</code> within the core that defines the <code>foo</code> arm. Instead\nwe want to modify the <strong>product</strong> of <code>foo</code>\u2014the gate\u2014so we have to pin it\ninto the subject.</p>\n\n<p>Here's that again in tall form:</p>\n\n<p><code><pre>\n=+  foo\n=&gt;  %=  +2\n      +6  baz:+3\n    ==\n  $\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo [p=5 q=6]</p>\n</blockquote>\n\n<blockquote>\n  <p>foo(p 42)\n  [p=42 q=6]</p>\n</blockquote>\n\n<blockquote>\n  <p>foo(+3 99)\n  [p=5 99]\n  </pre></code></p>\n</blockquote>\n",
    ":-": "<p><code>:-</code> \"colhep\"</p>\n\n<p>Construct a cell (2-tuple).</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  :-  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  :-(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular #1</td>\n  <td style=\"text-align:center;\"><pre>  [p q]<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular #2</td>\n  <td style=\"text-align:center;\"><pre><p>    p^q<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%clhp p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>The cell of <code>p</code> and <code>q</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>Hoon expressions actually use the same \"autocons\" pattern as Nock\nformulas. If you're assembling expressions (which usually only the\ncompiler does), <code>[a b]</code> is the same as <code>:-(a b)</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>:-(1 2)\n  [1 2]</p>\n</blockquote>\n\n<p>~zod:dojo> 1^2\n[1 2]\n</pre></code></p>\n\n<hr />\n",
    ":_": "<p><code>:_</code> \"colcab\"</p>\n\n<p>Construct a cell, inverted.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  :_  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  :_(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%clcb p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n:-(q p)\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>:_(1 2)\n  [2 1]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ":+": "<p><code>:+</code> \"collus\"</p>\n\n<p>Construct a triple (3-tuple).</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  :+  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  :+(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    [p q r]<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%clls p=hoon q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Expands to:</h4>\n\n<p><code><pre>\n:-(p :-(q r))\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>:+  1\n      2\n    3\n  [1 2 3]</p>\n</blockquote>\n\n<blockquote>\n  <p>:+(%a ~ 'b')\n  [%a ~ 'b']\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ":^": "<p><code>:^</code> \"colket\"</p>\n\n<p>Construct a quadruple (4-tuple).</p>\n\n<h4>Syntax</h4>\n\n<p>Four arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  :^    p<p>      q<p>    r<p>  s<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  :^(p q r s)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    [p q r s]<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%clkt p=hoon q=hoon r=hoon s=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n:-(p :-(q :-(r s)))\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>:^(1 2 3 4)\n  [1 2 3 4]</p>\n</blockquote>\n\n<blockquote>\n  <p>:^    5\n        6\n      7\n    8\n  [5 6 7 8]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ":*": "<p><code>:*</code> \"coltar\"</p>\n\n<p>Construct an n-tuple.</p>\n\n<h4>Syntax</h4>\n\n<p>Variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  :*  p1<p>      p2<p>      p3<p>      pn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  :*(p1 p2 p3 pn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    [p1 p2 p3 pn]<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%cltr p=(list hoon)]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><strong>Pseudocode</strong>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>p</code>:</p>\n\n<p><code><pre>\n:-(a :-(b :-(c :-(... z)))))\n</pre></code></p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n|-\n?~  p\n  !!\n?~  t.p\n  i.p\n:-  i.p\n$(p t.p)\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>:*(5 3 4 1 4 9 0 ~ 'a')\n  [5 3 4 1 4 9 0 ~ 'a']</p>\n</blockquote>\n\n<blockquote>\n  <p>[5 3 4 1 4 9 0 ~ 'a']\n  [5 3 4 1 4 9 0 ~ 'a']</p>\n</blockquote>\n\n<blockquote>\n  <p>:*  5\n        3\n        4\n        1\n        4\n        9\n        0\n        ~\n        'a'\n    ==\n  [5 3 4 1 4 9 0 ~ 'a']\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ":~": "<p><code>:~</code> \"colsig\"</p>\n\n<p>Construct a null-terminated list.</p>\n\n<h4>Syntax</h4>\n\n<p>Variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  :~  p1<p>      p2<p>      p3<p>      pn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  :~(p1 p2 p3 pn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    ~[p1 p2 p3 pn]<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%clsg p=(list hoon)]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><strong>Pseudocode</strong>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>p</code>:</p>\n\n<p><code><pre>\n:-(a :-(b :-(c :-(... :-(z ~)))))\n</pre></code></p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n|-\n?~  p\n  ~\n:-  i.p\n$(p t.p)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>Note that this does not produce a <code>list</code> type, it just produces a\nnull-terminated n-tuple. To make it a proper <code>list</code> it must be cast or molded.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>:~(5 3 4 2 1)\n  [5 3 4 2 1 ~]</p>\n</blockquote>\n\n<blockquote>\n  <p>~[5 3 4 2 1]\n  [5 3 4 2 1 ~]</p>\n</blockquote>\n\n<blockquote>\n  <p>:~  5\n        3\n        4\n        2\n        1\n    ==\n  [5 3 4 2 1 ~]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "::": "<p><code>::</code> \"colcol\"</p>\n\n<p>Code comment.</p>\n\n<h4>Syntax</h4>\n\n<p><code><pre>\n::  any text you like!\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p><code><pre>\n::\n::  this is commented code\n::\n|=  a=@         ::  a gate\n(add 2 a)       ::  that adds 2\n                ::  to the input\n</pre></code></p>\n",
    ".^": "<p><code>.^</code> \"dotket\"</p>\n\n<p>Load from the Arvo namespace (scry) with a fake Nock instruction: Nock 12.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, with the second optionally split into an arbitrary number of\nelements.</p>\n\n<p>While this rune technically takes a fixed number of arguments, <code>q</code> is usually\nsplit into at least two parts, and the tall form of this rune must be terminated\nwith a <code>==</code>. Note also that the <code>==</code> does not make the arguments into a list as\nyou might expect, so <code>q</code> must be explicitly null-terminated if its elements are\nspecified separately.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  .^  p<p>    q1<p>    q2<p>    q3<p>    qn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  .^(p q1 q2)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%dtkt p=spec q=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>The noun <code>q</code>, cast to the type <code>p</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>Nock has no <code>12</code> instruction! But the virtual Nock\nused to run userspace code does. Nock <code>12</code> loads from a\ntyped immutable namespace defined by its virtual context.</p>\n\n<p>Ordinarily a Hoon expression has access to no information but whatever can be found in the subject. The one exception is with the <code>.^</code> rune. It essentially allows you to request information from one of the Arvo vanes (modules).</p>\n\n<p><code>.^</code> checks that the type of the value retrieved from Arvo nests under <code>p</code>. <code>q</code> is a <code>path</code> which includes information about which vane is being queried, and what sort of information is requested.</p>\n\n<p>In principle <code>.^</code> takes two subexpressions, but in practice <code>q</code> is often given in two parts: the first part includes the vane to be queried (e.g., <code>%a</code> for Ames, <code>%b</code> for Behn, <code>%c</code> for Clay, etc.) and the kind of request. The second part is a path that corresponds to the kind of request.</p>\n\n<h4>Examples</h4>\n\n<p>In the dojo we can ask Clay -- the Arvo filesystem -- for a listing of the files at our current path, <code>%</code>:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>.^(arch %cy %)\n  [ fil=~\n      dir\n    { [p=~.app q=~]\n      [p=~.sur q=~]\n      [p=~.gen q=~]\n      [p=~.lib q=~]\n      [p=~.mar q=~]\n      [p=~.ted q=~]\n      [p=~.desk q=~]\n      [p=~.sys q=~]\n    }\n  ]\n  </pre></code></p>\n</blockquote>\n\n<p>The <code>%c</code> is for Clay, and the <code>y</code> is for the request type. <code>arch</code> is the type of the listing. See <code>gen/cat.hoon</code> to see how this information is printed more prettily.</p>\n\n<p>The <code>%</code> is for the current path in the dojo:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p><code>path</code>%\n  /~zod/base/~2018.9.20..23.05.35..0231\n  </pre></code></p>\n</blockquote>\n\n<p>You can modify the time of the file listing quite simply and ask for a listing from 5 hours ago. (Remember that Clay is a revision-controlled file system.)</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>.^(arch %cy /(scot %p our)/base/(scot %da (sub now ~h5)))\n  [ fil=~\n      dir\n    { [p=~.app q=~]\n      [p=~.sur q=~]\n      [p=~.gen q=~]\n      [p=~.lib q=~]\n      [p=~.mar q=~]\n      [p=~.ted q=~]\n      [p=~.desk q=~]\n      [p=~.sys q=~]\n    }\n  ]\n  </pre></code></p>\n</blockquote>\n\n<p><code>our</code> is the value for your ship's name.</p>\n\n<hr />\n",
    ".+": "<p><code>.+</code> \"dotlus\"</p>\n\n<p>Increment an atom with Nock <code>4</code>.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  .+  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  .+(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    +(p)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%dtls p=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>p</code> plus <code>1</code> if <code>p</code> is an atom; otherwise, crashes. The product atom has no aura.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>.+(6)\n  7</p>\n</blockquote>\n\n<blockquote>\n  <p>+(6)\n  7</p>\n</blockquote>\n\n<blockquote>\n  <p>+(%foo)\n  7.303.015</p>\n</blockquote>\n\n<blockquote>\n  <p>+([1 2])\n  nest-fail\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ".*": "<p><code>.*</code> \"dottar\"</p>\n\n<p>Evaluate with Nock <code>2</code>.</p>\n\n<h4>Produces</h4>\n\n<p>Nock of formula <code>q</code> and subject <code>p</code>, with type <code>%noun</code>.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  .*  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  .*(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%dttr p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>.*(p q)</code> is used to run Nock formula <code>q</code> on the subject <code>p</code> from within Hoon.</p>\n\n<p>Keep in mind that <code>p</code> and <code>q</code> can be arbitrary Hoon expressions, as long as they evaluate to the appropriate nouns for Nock evaluation.</p>\n\n<p>Note also that <code>.*</code> (\"dottar\") can be used to bypass the type system. It's\ntherefore possible to use Hoon as a typeless language.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>.*([20 30] [0 2])\n  20</p>\n</blockquote>\n\n<blockquote>\n  <p>.*(33 [4 0 1])\n  34</p>\n</blockquote>\n\n<blockquote>\n  <p>.*(|.(50) [9 2 0 1])\n  50</p>\n</blockquote>\n\n<blockquote>\n  <p>.*(12 [7 [<code>1 [4</code>1]] [<code>2</code>3 `2]])\n  [12 13 12]</p>\n</blockquote>\n\n<blockquote>\n  <p>.*(~ [5 1^4 [4 1^3]])\n  0</p>\n</blockquote>\n\n<blockquote>\n  <p>.*(~ [5 1^5 [4 1^3]])\n  1\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ".=": "<p><code>.=</code> \"dottis\"</p>\n\n<p>Test for equality with Nock <code>5</code>.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  .=  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  .=(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    =(p q)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%dtts p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>%.y</code> if <code>p</code> equals <code>q</code>; otherwise <code>%.n</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>Like Nock equality, <code>.=</code> (\"dottis\") tests whether two nouns are the same,\nignoring invisible pointer structure. Because in a conventional noun\nimplementation each noun has a lazy short hash, comparisons are fast unless the\nhash needs to be computed, or we are comparing separate copies of identical\nnouns. (Comparing large duplicates is a common cause of performance bugs.)</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>.=(0 0)\n  %.y</p>\n</blockquote>\n\n<blockquote>\n  <p>=(0 0)\n  %.y</p>\n</blockquote>\n\n<blockquote>\n  <p>.=(1 2)\n  %.n</p>\n</blockquote>\n\n<blockquote>\n  <p>=(1 2)\n  %.n</p>\n</blockquote>\n\n<blockquote>\n  <p>=(12 [12 14])\n  %.n\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ".?": "<p><code>.?</code> \"dotwut\"</p>\n\n<p>Test for cell or atom with Nock <code>3</code>.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  .?  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  .?(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%dtwt p=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>%.y</code> if <code>p</code> is a cell; otherwise <code>%.n</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>.?(42)\n  %.n</p>\n</blockquote>\n\n<blockquote>\n  <p>.?([42 43])\n  %.y\n  </pre></code></p>\n</blockquote>\n",
    "/-": "<p><code>/-</code> \"fashep\"</p>\n\n<p>Import structure libraries from <code>/sur</code>.</p>\n\n<h4>Syntax</h4>\n\n<p><code><pre>\n/-  foo, bar, baz\n</pre></code></p>\n\n<p>Note there is only a single space between each item.</p>\n\n<h4>Semantics</h4>\n\n<p>Names correspond to files in the <code>/sur</code> directory of the same desk as this file, e.g.\n<code>/sur/foo.hoon</code> for <code>foo</code>. Names containing hyphens, e.g. <code>foo-abc</code>, will first\nresolve to <code>/sur/foo-abc.hoon</code>, and if that doesn't exist, it will try\n<code>/sur/foo/abc.hoon</code>.</p>\n\n<p>Imports may be given a different face by doing <code>xyz=foo</code>. Imports may have their\nface stripped (so you can directly reference their wings) with <code>*foo</code>.</p>\n\n<hr />\n",
    "/+": "<p><code>/+</code> \"faslus\"</p>\n\n<p>Import libraries from <code>/lib</code>.</p>\n\n<h4>Syntax</h4>\n\n<p><code><pre>\n/+  foo, bar, baz\n</pre></code></p>\n\n<p>Note there is only a single space between each item.</p>\n\n<h4>Semantics</h4>\n\n<p>Names correspond to files in the <code>/lib</code> directory of the same desk as this file,\ne.g. <code>/lib/foo.hoon</code> for <code>foo</code>. Names containing hyphens, e.g. <code>foo-abc</code>, will\nfirst resolve to <code>/lib/foo-abc.hoon</code>, and if that doesn't exist, it will try\n<code>/lib/foo/abc.hoon</code>.</p>\n\n<p>Imports may be given a different face by doing <code>xyz=foo</code>. Imports may have their\nface stripped (so you can directly reference their wings) with <code>*foo</code>.</p>\n\n<hr />\n",
    "/=": "<p><code>/=</code> \"fastis\"</p>\n\n<p>Build and import a hoon file at the specified path.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments.</p>\n\n<p><code><pre>\n/=  some-face  /path/to/file\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>This lets you build and import a hoon file from anywhere in the desk.</p>\n\n<p>The first argument is the face to pin it as. The second argument is the path to\nthe file in the same desk as this file. The file must be a <code>%hoon</code> file, and the\ntrailing mark (<code>hoon</code>) must be omitted from the path.</p>\n\n<h4>Examples</h4>\n\n<p>To build and import <code>/foo/bar.hoon</code> you would do:</p>\n\n<p><code><pre>\n/=  foobar  /foo/bar\n</pre></code></p>\n\n<hr />\n",
    "/*": "<p><code>/*</code> \"fastar\"</p>\n\n<p>Import the file at the specified path as the specified mark.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments.</p>\n\n<p><code><pre>\n/*  some-face  %as-mark  /path/to/file\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>The first argument is the face to pin it as. The second argument is the mark it\nshould be converted to. The third argument is the path to the file in the same\ndesk as this file, with the trailing mark included.</p>\n\n<p>The mark specified may be different to the mark of the file, as long as\nconversion is possible. Note that a <code>%hoon</code> file will not be built like with\n<code>/=</code>: the type of a <code>%hoon</code> file is a <code>@t</code> so that is what will be pinned.</p>\n\n<h4>Examples</h4>\n\n<p>To import <code>/foo/bar.hoon</code> you would do:</p>\n\n<p><code><pre>\n/*  foobar  %hoon  /foo/bar/hoon\n</pre></code></p>\n\n<p><code>foobar</code> would then be an <code>@t</code> of the contents of that file.</p>\n\n<hr />\n",
    "/$": "<p><code>/$</code> \"fasbuc\"</p>\n\n<p>Import mark conversion gate.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments.</p>\n\n<p><code><pre>\n/$  some-face   %from-mark   %to-mark\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>The first argument is the face to pin it as. The second argument is the mark to\nconvert <em>from</em>. The third argument is the mark to convert <em>to</em>.</p>\n\n<p>The result will be a gate of <code>$-(type-1 type-2)</code>, pinned with the specified\nface. The types are the data types of the <em>from</em> mark and <em>to</em> mark,\nrespectively.</p>\n\n<p>The mark conversion gate will be built from marks in <code>/mar</code> on the same desk as\nthis file.</p>\n\n<h4>Examples</h4>\n\n<p>To build a mark conversion gate from <code>%txt</code> to <code>%mime</code>, you would do:</p>\n\n<p><code><pre>\n/$  txt-to-mime  %txt  %mime\n</pre></code></p>\n\n<p><code>txt-to-mime</code> would be a gate of <code>$-(wain mime)</code>. You could then call the gate\nlike:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(txt-to-mime ~['first line' 'second line'])\n  [p=/text/plain q=[p=22 q=37.949.953.370.267.411.298.483.129.707.945.775.026.849.432.323.909.990]]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "/~": "<p><code>/~</code> \"fassig\"</p>\n\n<p>Import, build, evaluate and pin the results of many hoon files in a directory.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments.</p>\n\n<p><code><pre>\n/~  some-face  some-type  /some/directory</p>\n\n</pre></code>\n\n<h4>Semantics</h4>\n\nThe first argument is the face to pin the results with. The second argument is\nthe type each hoon file produces when evaluated. The third argument is the path\nto a directory in the same desk as this file, containing `%hoon` files.\n\nEach hoon file in the specified directory will be built and evalutated. The\nresult of evaluating each file will be added to a\n[`++map`](https://developers.urbit.org/reference/hoon/stdlib/2o#map) and pinned with the specified face\n(`some-face`). The keys of the map will be the name of each file, and the values\nof the map will be the result of evaluating each file and casting its result to\nthe type specified (`some-type`).\n\nAll of the hoon files in the specified directory, when evaluated, must produce\ndata of a type that nests under the type specified (`some-type`). File with a\nmark other than `%hoon` will be ignored.\n\nThe type of the map will be `(map knot some-type)`.\n\n<h4>Examples</h4>\n\nIf the `/foo/bar` directory contains three files:\n\n<ul>\n\n<p><li><code>x.hoon</code> containing <code>(silt ~[1 2 3 4 5])</code></li>\n<li><code>y.hoon</code> containing <code>(silt ~[99 100])</code></li>\n<li><code>z.hoon</code> containing <code>(silt ~[22 33 44])</code></li>\n</ul></p>\n\n<p>Then the following <code>/~</code> expression:</p>\n\n<p><code><pre>\n/~  foo  (set @ud)  /foo/bar\n</pre></code></p>\n\n<p>...will pin a <code>(map knot (set @ud))</code> with a face of <code>foo</code> which contains:</p>\n\n<p></pre></code>\n{[p=~.y q={100 99}] [p=~.z q={22 33 44}] [p=~.x q={5 1 2 3 4}]}\n</pre></code></p>\n\n<hr />\n",
    "/%": "<p><code>/%</code> \"fascen\"</p>\n\n<p>Build and import a mark core.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments.</p>\n\n<p><code><pre>\n/%  some-face  %some-mark\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>The first argument is a face to pin the mark core with. The second argument is a\nmark.</p>\n\n<p>The static mark core (a <code>nave:clay</code>) for the specified mark (which resides in\nthe same desk as the file) is built and pinned to the subject with the specified\nface.</p>\n\n<h4>Examples</h4>\n\n<p>To build the mark core for the <code>%txt</code> mark:</p>\n\n<p><code><pre>\n/%  foo  %txt\n</pre></code></p>\n\n<p>Its arms can then be accessed like:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>form:foo\n  %txt-diff\n  </pre></code></p>\n</blockquote>\n",
    "^|": "<p><code>^|</code> \"ketbar\"</p>\n\n<p>Convert a gold core to an iron core (contravariant).</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^|  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^|(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%ktbr p=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>p</code> as an iron core; crash if not a gold core.</p>\n\n<h4>Discussion</h4>\n\n<p>An iron core is an opaque function (gate or door).</p>\n\n<p>Theorem: if type <code>x</code> nests within type <code>a</code>, and type <code>y</code> nests\nwithin type <code>b</code>, a core accepting <code>b</code> and producing <code>x</code> nests\nwithin a iron core accepting <code>y</code> and producing <code>a</code>.</p>\n\n<p>Informally, a function fits an interface if the function has a\nmore specific result and/or a less specific argument than the\ninterface.</p>\n\n<h4>Examples</h4>\n\n<p>The prettyprinter shows the core metal (<code>.</code> gold, <code>|</code> iron):</p>\n\n<p></pre></code>\n~zod:dojo> |=(@ 1)\n&lt;1.gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151>]&gt;</p>\n\n<p>~zod:dojo> ^|(|=(@ 1))\n&lt;1|gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151>]&gt;\n</pre></code></p>\n\n<hr />\n",
    "^:": "<p><code>^:</code> \"ketcol\"</p>\n\n<p>Switch parser into structure mode (mold definition) and produce a gate for type <code>p</code>.  (See <a href=\"\"><code>,</code> com</a> which toggles modes.)</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^:  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^:(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>  ,p<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%ktcl p=spec]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>A gate that returns the sample value if it is of the correct type, but crashes\notherwise.</p>\n\n<h4>Discussion</h4>\n\n<p><code>^:</code> is used to produce a mold that crashes if its sample is of the wrong type.</p>\n\n<p>In structure mode, <code>[a=@ b=@]</code> is a mold for a cell, whereas in value mode it's\na pair of molds.  Sometimes you need a structure in value mode, in which you can\nuse <code>^:</code> or <code>,</code>.</p>\n\n<p>Molds used to produced their bunt value if they couldn't mold their sample. This\nis no longer the case: molds now crash if molding fails, so this rune is\nredundant in certain cases.</p>\n\n<p>One may expect that <code>^:(path /foo)</code> would result in a syntax error since <code>^:</code>\nonly takes one child, but instead it will parse as <code>=&lt; ^ %:(path /foo)</code>. Since\n<code>:</code> is the irregular syntax for <code>=&lt;</code> this is is parsed as \"get <code>^</code> (i.e. the\nmold for cells) from a subject of <code>(path /foo)</code>\", with <code>:</code> being the irregular\nsyntax for <code>=&lt;</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>^:  @\n  &lt; 1.goa\n    { *\n      {our/@p now/@da eny/@uvJ}\n      &lt;19.hqf 23.byz 5.mzd 36.apb 119.zmz 238.ipu 51.mcd 93.glm 74.dbd 1.qct $141>\n    }</p>\n</blockquote>\n\n<blockquote>\n  <p>(^:(@) 22)\n  22</p>\n</blockquote>\n\n<blockquote>\n  <p>(^:(@) [22 33])\n  ford: %ride failed to execute:</p>\n</blockquote>\n\n<blockquote>\n  <p>(,cord 55)\n  '7'</p>\n</blockquote>\n\n<blockquote>\n  <p>(ream ',@t')\n  [%ktcl p=[%base p=[%atom p=~.t]]]</p>\n</blockquote>\n\n<blockquote>\n  <p>(ream ',cord')\n  [%ktcl p=[%like p=~[%cord] q=~]]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "^.": "<p><code>^.</code> \"ketdot\"</p>\n\n<p>Typecast on value produced by passing <code>q</code> to <code>p</code>.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^.  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^.(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%ktdt p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n^+(%:(p q) q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>p</code> produces a gate and q is any Hoon expression.</p>\n\n<p><code>^.</code> is particularly useful when <code>p</code> is a gate that 'cleans up' the type information about some piece of data. For example, <code>limo</code> is used to turn a raw noun of the appropriate shape into a genuine list. Hence we can use <code>^.</code> to cast with <code>limo</code> and similar gates, ensuring that the product has the desired type.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=mylist [11 22 33 ~]</p>\n</blockquote>\n\n<blockquote>\n  <p>?~(mylist ~ i.mylist)\n  mint-vain</p>\n</blockquote>\n\n<blockquote>\n  <p>=mylist ^.(limo mylist)</p>\n</blockquote>\n\n<blockquote>\n  <p>?~(mylist ~ i.mylist)\n  11</p>\n</blockquote>\n\n<blockquote>\n  <p>?~(mylist ~ t.mylist)\n  ~[22 33]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "^-": "<p><code>^-</code> \"kethep\"</p>\n\n<p>Typecast by explicit type label.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^-  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^-(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    <code>p</code>q<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%kthp p=spec q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n^+(^*(p) q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>It's a good practice to put a <code>^-</code> (\"kethep\") at the top of every arm\n(including gates, loops, etc). This cast is strictly necessary\nonly in the presence of head recursion (otherwise you'll get a\n<code>rest-loop</code> error, or if you really screw up spectacularly an\ninfinite loop in the compiler).</p>\n\n<h4>Examples</h4>\n\n<p></pre></code>\n~zod:dojo> (add 90 7)\n97</p>\n\n<p>~zod:dojo> <code>@t</code>(add 90 7)\n'a'</p>\n\n<p>~zod:dojo> ^-(@t (add 90 7))\n'a'</p>\n\n<p>/~zod:dojo> =foo |=  a=@\n                 ^-  (unit @ta)\n                 `a</p>\n\n<p>/~zod:dojo> (foo 97)\n[~ ~.a]\n</pre></code></p>\n",
    "^+": "<p><code>^+</code> \"ketlus\"</p>\n\n<p>Typecast by inferred type.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^+  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^+(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%ktls p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>The value of <code>q</code> with the type of <code>p</code>, if the type of <code>q</code> nests within the type\nof <code>p</code>. Otherwise, <code>nest-fail</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code>\n~zod:dojo> ^+('text' %a)\n'a'\n</pre></code></p>\n\n<hr />\n",
    "^&": "<p><code>^&amp;</code> \"ketpam\"</p>\n\n<p>Convert a core to a zinc core (covariant).</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^&amp;  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^&amp;(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%ktpm p=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>p</code> as a zinc core; crash if <code>p</code> isn't a gold or zinc core.</p>\n\n<h4>Discussion</h4>\n\n<p>A zinc core has a read-only sample and an opaque context. See <a href=\"https://developers.urbit.org/reference/hoon/advanced\">Advanced types</a>.</p>\n\n<h4>Examples</h4>\n\n<p>The prettyprinter shows the core metal in the arm labels <code>1.xoz</code> and <code>1&amp;xoz</code>\nbelow (<code>.</code> is gold, <code>&amp;</code> is zinc):</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>|=(@ 1)\n  &lt; 1.xoz\n    { @\n      {our/@p now/@da eny/@uvJ}\n      &lt;19.hqf 23.byz 5.mzd 36.apb 119.zmz 238.ipu 51.mcd 93.glm 74.dbd 1.qct $141>\n    }</p>\n</blockquote>\n\n<blockquote>\n  <p>^&amp;(|=(@ 1))\n  &lt; 1&amp;xoz\n    { @\n      {our/@p now/@da eny/@uvJ}\n      &lt;19.hqf 23.byz 5.mzd 36.apb 119.zmz 238.ipu 51.mcd 93.glm 74.dbd 1.qct $141>\n    }</p>\n  \n  <p></pre></code></p>\n</blockquote>\n\n<p>You can read from the sample of a zinc core, but not change it:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=mycore ^&amp;(|=(a=@ 1))</p>\n</blockquote>\n\n<blockquote>\n  <p>a.mycore\n  0</p>\n</blockquote>\n\n<blockquote>\n  <p>mycore(a 22)\n  -tack.a\n  -find.a\n  ford: %slim failed:\n  ford: %ride failed to compute type:\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "^~": "<p><code>^~</code> \"ketsig\"</p>\n\n<p>Fold constant at compile time.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^~  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^~(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%ktsg p=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>p</code>, folded as a constant if possible.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(make '|-(42)')\n  [%8 p=[%1 p=[1 42]] q=[%9 p=2 q=[%0 p=1]]]</p>\n</blockquote>\n\n<blockquote>\n  <p>(make '^~(|-(42))')\n  [%1 p=42]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "^*": "<p><code>^*</code> \"kettar\"</p>\n\n<p>Produce example type value.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^*  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^*(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    *p<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<p><code>p</code> is any structure expression.</p>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%kttr p=spec]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>A default value (i.e., 'bunt value') of the type <code>p</code>.</p>\n\n<h4>Examples</h4>\n\n<p>Regular:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>^*  @\n  0</p>\n</blockquote>\n\n<blockquote>\n  <p>^*  %baz\n  %baz</p>\n</blockquote>\n\n<blockquote>\n  <p>^*  ^\n  [0 0]</p>\n</blockquote>\n\n<blockquote>\n  <p>^*  ?\n  %.y\n  </pre></code></p>\n</blockquote>\n\n<p>Irregular:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>*@\n  0</p>\n</blockquote>\n\n<blockquote>\n  <p>*^\n  [0 0]</p>\n</blockquote>\n\n<blockquote>\n  <p>*tape\n  \"\"\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "^=": "<p><code>^=</code> \"kettis\"</p>\n\n<p>Bind name to a value.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^=  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^=(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    p=q<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%ktts p=skin q=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>If <code>p</code> is a term, the product <code>q</code> with type <code>[%face p q]</code>. <code>p</code> may also be a\ntuple of terms, or a term-skin pair; the type of <code>q</code> must divide evenly into\ncells to match it.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>a=1\n  a=1</p>\n</blockquote>\n\n<blockquote>\n  <p>^=  a\n    1\n  a=1</p>\n</blockquote>\n\n<blockquote>\n  <p>^=(a 1)\n  a=1</p>\n</blockquote>\n\n<blockquote>\n  <p>[b c d]=[1 2 3 4]\n  [b=1 c=2 d=[3 4]]</p>\n</blockquote>\n\n<blockquote>\n  <p>[b c d=[x y]]=[1 2 3 4]\n  [b=1 c=2 d=[x=3 y=4]]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "^?": "<p><code>^?</code> \"ketwut\"</p>\n\n<p>Convert any core to a lead core (bivariant).</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ^?  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ^?(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%ktwt p=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>p</code> as a lead core; crash if not a core.</p>\n\n<h4>Discussion</h4>\n\n<p>A lead core is an opaque generator; the payload can't be read or\nwritten.</p>\n\n<p>Theorem: if type <code>x</code> nests within type <code>a</code>, a lead core producing\n<code>x</code> nests within a lead core producing <code>a</code>.</p>\n\n<p>Informally, a more specific generator can be used as a less\nspecific generator.</p>\n\n<h4>Examples</h4>\n\n<p>The prettyprinter shows the core metal (<code>.</code> gold, <code>?</code> lead):</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>|=(@ 1)\n  &lt;1.gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151>]&gt;</p>\n</blockquote>\n\n<blockquote>\n  <p>^?(|=(@ 1))\n  &lt;1?gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151>]&gt;\n  </pre></code></p>\n</blockquote>\n",
    "+|": "<p><code>+|</code> \"lusbar\"</p>\n\n<p>Chapter label (not useful)</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  +|  %label<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>Discussion</h4>\n\n<p>The <code>+|</code> doesn't produce an arm. It instead provides a label for the arms that\nfollow it. The arms of a core can be divided into <strong>chapters</strong> for\n'organization'. Chapter labels aren't part of the underlying noun of the core;\nthey're stored as type system metadata only.</p>\n\n<p>See <a href=\"https://developers.urbit.org/reference/hoon/stdlib/4o#tome\"><code>tome</code></a> in the Hoon standard library.</p>\n\n<p><strong>Note:</strong> The <code>+|</code> rune has little practical utility. Chapter labels cannot be\nreferenced short of manually processing the <code>$type</code> of a core.</p>\n\n<h4>Examples</h4>\n\n<p>Let's look at what the Hoon compiler's parser, <code>ream</code>, does with the <code>+|</code> rune:</p>\n\n</pre></code>\n<blockquote>\n\n<p><p>(ream '|%  +|  %numbers  ++  two  2  ++  three  3  --')\n  [ %brcn\n    p=~\n      q\n    { [ p=%numbers\n        q=[p=~ q={[p=%three q=[%sand p=%ud q=3]] [p=%two q=[%sand p=%ud q=2]]}]\n      ]\n    }\n  ]\n  </pre></code></p>\n</blockquote></p>\n\n<p>Notice that <code>p.q</code> has the label <code>%numbers</code>. Contrast with:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(ream '|%  ++  two  2  ++  three  3  --')\n  [ %brcn\n    p=~\n      q\n    { [ p=%$\n        q=[p=~ q={[p=%three q=[%sand p=%ud q=3]] [p=%two q=[%sand p=%ud q=2]]}]\n      ]\n    }\n  ]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "+$": "<p><code>+$</code> \"lusbuc\"</p>\n\n<p>Produce a structure arm (type definition).</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  +$  p=term  q=spec<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code>p</code> is an arm name, and <code>q</code> is any structure expression.</p>\n\n<h4>Discussion</h4>\n\n<p>Arms produced by <code>+$</code> are essentially type definitions. They should be used when one wants to define custom types using core arms.</p>\n\n<p>The Hoon subexpression, <code>q</code>, must be a structure expression. That is, it must be\neither a basic structure expression (<code>*</code>, <code>~</code>, <code>^</code>, <code>?</code>, and <code>@</code>), or a complex\nexpression made with the <code>$</code> family of runes (including irregular variants).\nNames of structures are also permitted (e.g., <code>tape</code>).</p>\n\n<h4>Examples</h4>\n\n</pre></code>\n<blockquote>\n\n<p><p>=c |%\n         +$  atom-pair  $:(@ @)\n         +$  flag-atom  $:(? @)\n       --</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p><code>atom-pair.c</code>[12 14]\n  [12 14]</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p><code>atom-pair.c</code>[12 [22 33]]\n  nest-fail</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p><code>flag-atom.c</code>[&amp; 22]\n  [%.y 22]\n  </pre></code></p>\n</blockquote></p>\n\n<hr />\n",
    "++": "<p><code>++</code> \"luslus\"</p>\n\n<p>Produce a normal arm.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ++  p=term  q=hoon<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code>p</code> is the arm name, and <code>q</code> is any Hoon expression.</p>\n\n<h4>Discussion</h4>\n\n<p>All arms must have a name (e.g., <code>add</code>). An arm is computed by name resolution.\n(This resolution is implicit in the case of <code>$</code> arms. See <code>|=</code>, <code>|-</code>, and <code>|^</code>.)\nThe <code>++</code> rune is used for explicitly giving a name to an arm.</p>\n\n<p>Any Hoon expression, <code>q</code>, may be used to define the arm computation.</p>\n\n<h4>Examples</h4>\n\n</pre></code>\n<blockquote>\n\n<p><p>=c |%\n         ++  two  2\n         ++  increment  |=(a=@ +(a))\n       --</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p>two.c\n  2</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p>(increment.c 11)\n  12\n  </pre></code></p>\n</blockquote></p>\n\n<hr />\n",
    "+*": "<p><code>+*</code> \"lustar\"</p>\n\n<p>Defines deferred expressions within doors.</p>\n\n<h4>Syntax</h4>\n\n<p>Arguments: A variable number of pairs.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  +*  a=term  b=hoon<p>      c=term  d=hoon<p>      ...<p>      e=term  f=hoon<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code>a</code>, <code>c</code>, <code>e</code> are arm names and <code>b</code>, <code>d</code>, <code>f</code> are any Hoon expression. Note that\nunlike all other runes with a variable number of arguments, the list of\narguments of <code>+*</code> does not end with a terminator.</p>\n\n<p><code>+*</code> arms must always come at the beginning of the battery, before any other\ntype of lus arm.</p>\n\n<h4>Discussion</h4>\n\n<p>The primary use of <code>+*</code> is to create deferred expressions within doors (see\nExamples below). This is a name for an expressions that will be evaluated in\neach place the name is dereferenced. This is a similar concept to aliases or\nmacros, but there are some subtle but important differences. Deferred\nexpressions given by <code>+*</code> do not count towards the number of arms in the door\nand thus are also called \"virtual arms\", which can be important for things like\nGall agent cores that require a fixed number of arms.</p>\n\n<p>Under the hood, <code>+*</code> gets compiled as\n<a href=\"https://developers.urbit.org/reference/hoon/rune/tis#-tistar\"><code>=*</code>'s</a> (see here for more discussion on\ndeferred expressions). <code>+* foo bar</code> rewrites each <code>++</code> arm beneath it in the\ncore to include <code>=* foo bar</code>. For example, the interpreter sees the Nock\ncompiled from this Hoon expression</p>\n\n<p><code><pre>\n|_  z=@ud\n+*  n  1\n++  x  (add z n)</p>\n\n<h2>++  y  (sub z n)</h2>\n\n<p></pre></code></p>\n\n<p>as being identical the Nock compiled from this one:</p>\n\n<p><code><pre>\n=|  z=@ud\n|%\n++  x\n  =*  n  1\n  (add z n)\n++  y\n  =*  n  1</p>\n\n<h2>  (sub z n)</h2>\n\n<p></pre></code></p>\n\n<h4>Examples</h4>\n\n<p>To assign an alias to a door, we often write the following.</p>\n\n<p><code><pre>\n|_  foo\n+*  this  .\n</pre></code></p>\n\n<p>This is the idomatic way to assign the alias <code>this</code> to the door.</p>\n\n<p>Sometimes cores, such as Gall app cores, have a fixed number of arms, but you'd\nlike to include more. This is where aliases employed as \"virtual arms\" may be of\nuse. We note that it is often better style to compose cores with <code>=&gt;</code> or <code>=&lt;</code> to add more arms to a\nGall app core. This usage of <code>+*</code> is controversial and should be minimized.</p>\n\n<p><code><pre>\n|_  =bowl:gall\n+*  this  .\n    samp  +&lt;\n    cont  +&gt;\n</pre></code></p>\n\n<p>This assigns the door the alias <code>this</code>, the sample of the door <code>samp</code>, and the\ncontext of the door <code>cont</code>.</p>\n\n<p>You may also call functions with <code>+*</code> by making use of e.g. the <code>%~</code> rune.</p>\n\n<p><code><pre>\n=&lt;\n  |_  a=@\n  +*  do   ~(. +&gt; a)\n  ++  stuff  foo:do</p>\n\n<h2>::etc</h2>\n\n<p>|_  b=@\n++  foo  %bar</p>\n\n<h2>::etc</h2>\n\n<p></pre></code></p>\n",
    ";:": "<p><code>;:</code> \"miccol\"</p>\n\n<p>Call a binary function as an n-ary function.</p>\n\n<h4>Syntax</h4>\n\n<p>One fixed argument, then a variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ;:  p<p>    q1<p>    q2<p>    qn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ;:(p q1 q2 qn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    :(p q1 q2 qn)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%mccl p=hoon q=(list hoon)]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><strong>Pseudocode</strong>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>q</code>:</p>\n\n<p>Regular form:</p>\n\n<p><code><pre>\n%-(p a %-(p b %-(p c ...)))\n</pre></code></p>\n\n<p>Irregular form:</p>\n\n<p><code><pre>\n(p a (p b (p c ...)))\n</pre></code></p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n|-\n?~  q  !!\n?~  t.q  !!\n?~  t.t.q\n  (p i.q i.t.q)\n(p i.q $(q t.q))\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(add 3 (add 4 5))\n  12</p>\n</blockquote>\n\n<blockquote>\n  <p>;:(add 3 4 5)\n  12</p>\n</blockquote>\n\n<blockquote>\n  <p>:(add 3 4 5)\n  12</p>\n</blockquote>\n\n<blockquote>\n  <p><code>@t</code>:((cury cat 3) 'a' 'b' 'c' 'd')\n  'abcd'\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ";<": "<p><code>;&lt;</code> \"micgal\"</p>\n\n<p>Monadic do notation.</p>\n\n<h4>Syntax</h4>\n\n<p>Four arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ;&lt;  mold  bind  expr1  expr2<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ;&lt;(mold bind expr1 expr2)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%mcgl p=spec q=hoon r=hoon s=hoon]\n</pre></code></p>\n\n<h4>Semantics</h4>\n\n<p>A <code>;&lt;</code> is for sequencing two computations, <code>expr1</code> and <code>expr2</code>, using a provided\nimplementation of monadic bind. This rune takes a gate <code>bind</code> which takes a mold\n<code>mold</code> and produces an implementation of monadic bind.</p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n%+  (bind mold)\n  expr1\n|=  mold\nexpr2\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>;&lt;</code> is much like Haskell <code>do</code> notation. You have a sequence of events you'd\nlike to run such that each past the first depends on the output of the previous\none. The output of the previous one may not be of the correct type to use as an\ninput to the next one, and so an adapter such as <code>+biff</code> is needed.</p>\n\n<p><code>;&lt;</code> differs from <a href=\"#-micsig\"><code>;~</code></a> in that it takes a gate which takes a mold\nthat produces an implementation of monadic bind, rather than taking an\nimplementation of monadic bind directly.</p>\n\n<p><code>;&lt;</code> can be used to glue a pipeline together to run an asynchronous function or\nevent. This can be helpful when deferring parts of a computation based on\nexternal data.</p>\n\n<p>We remark that you can switch binds in the middle of a sequence of <code>;&lt;</code>.</p>\n\n<h4>Examples</h4>\n\n<p><a href=\"https://developers.urbit.org/reference/hoon/stdlib/2a/#biff\"><code>+biff</code></a> is the unit monad's\nimplementation of monadic bind. That is to say, it takes a unit <code>a</code> and a gate\n<code>b</code> that accepts a noun that produces a unit, and extracts the value from <code>a</code> to\npass as a sample to <code>b</code>.</p>\n\n<p>We illustrate the usage of <code>;&lt;</code> with <code>+biff</code> with a <code>map</code> of atoms:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=m (my ~[[1 3] [2 2] [3 1]])\n  (~(get by m) 1)\n  [~ 3]\n  </pre></code></p>\n</blockquote>\n\n<p>A single usage of <code>;&lt;</code> only serves to apply the binding function to the output\nof <code>expr1</code>:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>;&lt;  a=@  _biff  (~(get by m) 1)\n    a\n  3\n  </pre></code></p>\n</blockquote>\n\n<p>Here we see the result of chaining them together:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>;&lt;  a=@  _biff  (~(get by m) 1)\n    ;&lt;  b=@  _biff  (~(get by m) a)\n    b\n  1\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ";+": "<p><code>;+</code> \"miclus\"</p>\n\n<p>make a single XML node (Sail)</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ;+  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ;+(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code>p</code> is a Hoon expression that produces a <code>manx</code>.</p>\n\n<h4>Produces</h4>\n\n<p>A <a href=\"https://developers.urbit.org/reference/hoon/stdlib/5e#marl\"><code>marl</code></a>, i.e., a list of\n<a href=\"https://developers.urbit.org/reference/hoon/stdlib/5e#manx\"><code>manx</code></a>. A <code>manx</code> is a noun that\nrepresents a single XML node.</p>\n\n<h4>Discussion</h4>\n\n<p>tl;dr -- <code>;+</code> converts a <code>manx</code> to a <code>marl</code>.</p>\n\n<p><code>;+</code> is a Sail rune. Sail is a part of Hoon used for creating and operating on\nnouns that represent XML nodes. With the appropriate rendering pipeline, a Sail\ndocument can be used to generate a static website.</p>\n\n<p>In Sail a single XML node is represented by a <code>manx</code>. A single\n<code><p&gt;</code> node <code>manx</code> can be produced in the following way:</p>\n\n</pre></code>\n<blockquote>\n\n<p><p>;p: This will be rendered as an XML node.\n  [[%p ~] [[%$ [%$ \"This will be rendered as an XML node.\"] ~] ~] ~]\n  </pre></code></p>\n</blockquote></p>\n\n<p>Sometimes what is needed is a <code>marl</code>, i.e., a list of <code>manx</code>. To convert a\nsingle <code>manx</code> to a <code>marl</code>, use the <code>;+</code> rune.</p>\n\n<p>One interesting thing about Sail is that it allows you to use complex Hoon\nexpressions to choose from among several nodes to render. The <code>;+</code> rune can take\nsuch a complex expression.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>^-  marl\n    ;+  ?:  (gth 3 2)\n          ;p: This is the node for 'yes'.\n        ;p: This is the node for 'no'.\n  ~[\n    [ g=[n=%p a=~]\n      c=[i=[g=[n=%$ a=~[[n=%$ v=\"This is the node for 'yes'.\"]]] c=~] t=~]\n    ]\n  ]</p>\n</blockquote>\n\n<blockquote>\n  <p>^-  marl\n    ;+  ?:  (gth 2 3)\n          ;p: This is the node for 'yes'.\n        ;p: This is the node for 'no'.\n  ~[\n    [ g=[n=%p a=~]\n      c=[i=[g=[n=%$ a=~[[n=%$ v=\"This is the node for 'no'.\"]]] c=~] t=~]\n    ]\n  ]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ";;": "<p><code>;;</code> \"micmic\"</p>\n\n<p>Normalize with a mold, asserting fixpoint.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ;;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ;;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%mcmc p=spec q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=+  a=(p q)\n?>  =(<code>*</code>a <code>*</code>q)\na\n</pre></code></p>\n\n<blockquote>\n  <p>Note: the expansion implementation is hygienic -- it doesn't actually add the <code>a</code> face to the subject.</p>\n</blockquote>\n\n<h4>Examples</h4>\n\n<p>Fails because of auras:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>^-(tape ~[97 98 99])\n  mint-nice\n  -need.?(%~ [i=@tD t=\"\"])\n  -have.[@ud @ud @ud %~]\n  nest-fail\n  dojo: hoon expression failed\n  </pre></code></p>\n</blockquote>\n\n<p>Succeeds because molds don't care about auras:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>;;(tape ~[97 98 99])\n  \"abc\"\n  </pre></code></p>\n</blockquote>\n\n<p>Fails because not a fixpoint:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>;;(tape [50 51 52])\n  dojo: hoon expression failed\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ";/": "<p><code>;/</code> \"micfas\"</p>\n\n<p>Tape as XML element.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ;/  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ;/(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%mcnt p=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n~[%$ ~[%$ 'p']]\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>;/  \"foo\"\n  [[%~. [%~. \"foo\"] ~] ~]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ";~": "<p><code>;~</code> \"micsig\"</p>\n\n<p>Glue a pipeline together with a product-sample adapter.</p>\n\n<h4>Syntax</h4>\n\n<p>One fixed argument, then a variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ;~  p<p>    q1<p>    q2<p>    qn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ;~(p q1 q2 qn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%mcsg p=hoon q=(list hoon)]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>The gates in <code>q</code> are composed together using the gate <code>p</code> as an intermediate\nfunction, which transforms a <code>q</code> product and a <code>q</code> gate into a <code>q</code> sample.</p>\n\n<h4>Expands to</h4>\n\n<p><strong>Note: these are structurally correct, but elide some type-system complexity.</strong></p>\n\n<p><code>;~(a b)</code> reduces to <code>b</code>.</p>\n\n<p><code>;~(a b c)</code> expands to</p>\n\n<p><code><pre>\n|=  arg=*\n(a (b arg) c(+6 arg))\n</pre></code></p>\n\n<p><code>;~(a b c d)</code> expands to</p>\n\n<p><code><pre>\n|=  arg=*\n%+  a (b arg)\n=+  arg=arg\n|.  (a (c arg) d(+6 arg))\n</pre></code></p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n?~  q  !!\n|-\n?~  t.q  i.q\n=/  a  $(q t.q)\n=/  b  i.q\n=/  c  ,.+6.b\n|.  (p (b c) a(,.+6 c))\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>Apparently <code>;~</code> is a \"Kleisli arrow.\" It's also a close cousin of the infamous\n\"monad.\" Don't let that bother you. Hoon doesn't know anything about category\ntheory, so you don't need to either.</p>\n\n<p><code>;~</code> is often used in parsers, but is not only for parsers.</p>\n\n<p>This can be thought of as user-defined function composition; instead of simply\nnesting the gates in <code>q</code>, each is passed individually to <code>p</code> with the product\nof the previous gate, allowing arbitrary filtering, transformation, or\nconditional application.</p>\n\n<h4>Examples</h4>\n\n<p>A simple \"parser.\" <code>trip</code> converts a <code>cord</code> (atomic string) to\na <code>tape</code> (linked string).</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=cmp |=([a=tape b=$-(char tape)] <code>tape</code>?~(a ~ (weld (b i.a) t.a)))\n  ;~(cmp trip)\n  &lt;1.zje {a/@ &lt;409.yxa 110.lxv 1.ztu $151>}&gt;\n  </pre></code></p>\n</blockquote>\n\n<p>With just one gate in the pipeline <code>q</code>, the glue <code>p</code> is unused:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(;~(cmp trip) 'a')\n  \"a\"\n  </pre></code></p>\n</blockquote>\n\n<p>But for multiple gates, we need it to connect the pipeline:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(;~(cmp trip |=(a=@ ~[a a])) 'a')\n  \"aa\"</p>\n</blockquote>\n\n<blockquote>\n  <p>(;~(cmp trip |=(a=@ ~[a a])) '')\n  \"\"\n  </pre></code></p>\n</blockquote>\n\n<p>A more complicated example:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(;~(cmp trip ;~(cmp |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;))) 'b')\n  \"97b\"</p>\n</blockquote>\n\n<blockquote>\n  <p>(;~(cmp trip |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;)) 'b')\n  \"97b\"</p>\n</blockquote>\n\n<blockquote>\n  <p>(;~(cmp trip |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;)) '')\n  \"\"</p>\n</blockquote>\n\n<blockquote>\n  <p>(;~(cmp trip |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;)) 'a')\n  \"96a\"</p>\n</blockquote>\n\n<blockquote>\n  <p>(;~(cmp trip |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;)) 'acd')\n  \"96acd\"\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    ";*": "<p><code>;*</code> \"mictar\"</p>\n\n<p>make a list of XML nodes from complex Hoon expression (Sail)</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ;*  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ;*(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code>p</code> is a Hoon expression that produces a <code>marl</code>.</p>\n\n<h4>Produces</h4>\n\n<p>A <a href=\"https://developers.urbit.org/reference/hoon/stdlib/5e#marl\"><code>marl</code></a>, i.e., a list of\n<a href=\"https://developers.urbit.org/reference/hoon/stdlib/5e#manx\"><code>manx</code></a>. A <code>manx</code> is a noun that\nrepresents a single XML node.</p>\n\n<h4>Discussion</h4>\n\n<p><code>;*</code> is a Sail rune. Sail is a part of Hoon used for creating and operating on\nnouns that represent XML nodes. With the appropriate rendering pipeline, a Sail\ndocument can be used to generate a static website.</p>\n\n<p>If you need a complex Hoon expression to produce a <code>marl</code>, use the <code>;*</code> rune.\nOften this rune is used with an expression, <code>p</code>, that includes one or more <code>;=</code>\nsubexpressions.</p>\n\n<p>(See also <a href=\"#-mictis\"><code>;=</code></a>.)</p>\n\n<h4>Examples</h4>\n\n</pre></code>\n<blockquote>\n\n<p><p>;*  ?:  (gth 3 2)\n          ;=  ;p: This is node 1 of 'yes'.\n              ;p: This is node 2 of 'yes'.\n          ==\n        ;=  ;p: This is node 1 of 'no'.\n            ;p: This is node 2 of 'no'.\n        ==\n  [ [[%p ~] [[%$ [%$ \"This is node 1 of 'yes'.\"] ~] ~] ~]\n    [[[%p ~] [[%$ [%$ \"This is node 2 of 'yes'.\"] ~] ~] ~] ~]\n  ]</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p>;*  ?:  (gth 2 3)\n            ;=  ;p: This is node 1 of 'yes'.\n                ;p: This is node 2 of 'yes'.\n            ==\n          ;=  ;p: This is node 1 of 'no'.\n              ;p: This is node 2 of 'no'.\n          ==\n  [ [[%p ~] [[%$ [%$ \"This is node 1 of 'no'.\"] ~] ~] ~]\n    [[[%p ~] [[%$ [%$ \"This is node 2 of 'no'.\"] ~] ~] ~] ~]\n  ]\n  </pre></code></p>\n</blockquote></p>\n\n<hr />\n",
    ";=": "<p><code>;=</code> \"mictis\"</p>\n\n<p>make a list of XML nodes (Sail)</p>\n\n<h4>Syntax</h4>\n\n<p>A variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ;=  p1<p>      p2<p>      p3<p>     pn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ;=(p1 p2 p3 pn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code>p1</code>-<code>pn</code> are Hoon expressions, each of which poduces a <code>manx</code>.</p>\n\n<h4>Produces</h4>\n\n<p>A <a href=\"https://developers.urbit.org/reference/hoon/stdlib/5e#marl\"><code>marl</code></a>, i.e., a list of\n<a href=\"https://developers.urbit.org/reference/hoon/stdlib/5e#manx\"><code>manx</code></a>. A <code>manx</code> is a noun that\nrepresents a single XML node.</p>\n\n<h4>Discussion</h4>\n\n<p><code>;=</code> is a <a href=\"/guides/additional/sail\">Sail</a> rune. Sail is a part of Hoon used for\ncreating and operating on nouns that represent XML nodes. With the appropriate\nrendering pipeline, a Sail document can be used to generate a static website.</p>\n\n<p>In Sail a single XML node is represented by a <code>manx</code>. A single <code>&lt;p&gt;</code> node <code>manx</code>\ncan be produced in the following way:</p>\n\n</pre></code>\n<blockquote>\n\n<p><p>;p: This will be rendered as an XML node.\n  [[%p ~] [[%$ [%$ \"This will be rendered as an XML node.\"] ~] ~] ~]\n  </pre></code></p>\n</blockquote></p>\n\n<p>Sometimes what is needed is a <code>marl</code>, i.e., a list of <code>manx</code>. To convert a\nseries of <code>manx</code> nodes to a <code>marl</code>, use the <code>;=</code> rune.</p>\n\n<p>(See also <a href=\"#-mictar\"><code>;*</code></a>.)</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>;=  ;p: This is the first node.\n        ;p: This is the second.\n        ;p: Here is the last one.\n    ==\n  [ [[%p ~] [[%$ [%$ \"This is the first node.\"] ~] ~] ~]\n    [[%p ~] [[%$ [%$ \"This is the second.\"] ~] ~] ~]\n    [[%p ~] [[%$ [%$ \"Here is the last one.\"] ~] ~] ~]\n    ~\n  ]\n  </pre></code></p>\n</blockquote>\n",
    "~>": "<p><code>~&gt;</code> \"siggar\"</p>\n\n<p>Raw hint, applied to computation.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~&gt;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~&gt;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sggr p=$@(term [p=term q=hoon]) q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>q</code>.</p>\n\n<h4>Semantics</h4>\n\n<p><code>p</code> may either be a single <code>%term</code> or a pair of <code>[term hoon]</code>, the latter of\nwhich may optionally be be written <code>%foo.some-hoon</code>. <code>p</code> will be passed to the\ninterpreter and <code>q</code> will be evaluated and its result produced like normal.</p>\n\n<h4>Discussion</h4>\n\n<p>Hoon has no way of telling what hints are used and what aren't.\nHints are all conventions at the interpreter level.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>~&gt;(%a 42)\n  42\n  </pre></code></p>\n</blockquote>\n\n<p>Running the compiler:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(make '~&gt;(%a 42)')\n  [%11 p=97 q=[%1 p=42]]</p>\n</blockquote>\n\n<blockquote>\n  <p>(make '~&gt;(%a.+(2) 42)')\n  [%11 p=[p=97 q=[%4 p=[%1 p=2]]] q=[%1 p=42]]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "~|": "<p><code>~|</code> \"sigbar\"</p>\n\n<p>Tracing printf.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~|  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~|(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgbr p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>q</code>.</p>\n\n<h4>Convention</h4>\n\n<p>Prettyprints <code>p</code> in stack trace if <code>q</code> crashes.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>~|('sample error message' !!)\n  'sample error message'\n  dojo: hoon expression failed</p>\n</blockquote>\n\n<blockquote>\n  <p>~|  'sample error message'\n    !!\n  'sample error message'\n  dojo: hoon expression failed\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "~$": "<p><code>~$</code> \"sigbuc\"</p>\n\n<p>Profiling hit counter.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~&amp;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~&amp;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgbc p=term q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>q</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>If profiling is on, adds 1 to the hit counter <code>p</code>, which is a <code>term</code> like\n<code>%foo</code>. Profiling is enabled by passing the <code>-P</code> flag to the <code>urbit</code> binary.\nProfiling results are saved in <code>/path/to/pier/.urb/put/profile/~some.date.txt</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>~$(%foo 3)\n  3\n  </pre></code></p>\n</blockquote>\n\n<p>Assuming we have the binary running with the <code>-P</code> flag, if we do this:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=z |=  a=@\n       ?:  =(a 0)\n         a\n       ~$  %my-hit-counter\n       $(a (dec a))</p>\n</blockquote>\n\n<blockquote>\n  <p>(z 42)\n  0\n  </pre></code></p>\n</blockquote>\n\n<p>...then look in <code>/path/to/pier/.urb/put/profile/~some.date.txt</code>, we'll see this\nline near the top of the file:</p>\n\n<p></pre></code>\nmy-hit-counter: 42\n</pre></code></p>\n\n<hr />\n",
    "~_": "<p><code>~_</code> \"sigcab\"</p>\n\n<p>User-formatted tracing printf.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~_  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~_(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgcb p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>q</code>.</p>\n\n<h4>Convention</h4>\n\n<p>Shows <code>p</code> in stacktrace if <code>q</code> crashes.</p>\n\n<h4>Discussion</h4>\n\n<p><code>p</code> must produce a <code>tank</code> (pretty-print source).</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>~_([%leaf \"sample error message\"] !!)\n  sample error message\n  dojo: hoon expression failed</p>\n</blockquote>\n\n<blockquote>\n  <p>~_  [%leaf \"sample error message\"]\n    !!\n  sample error message\n  dojo: hoon expression failed\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "~%": "<p><code>~%</code> \"sigcen\"</p>\n\n<p>Jet registration.</p>\n\n<h4>Syntax</h4>\n\n<p>Four arguments. Two fixed arguments, then a third which may be <code>~</code> if empty or\nelse a variable number of pairs sandwiched between two <code>==</code>s, then a fourth\nfixed argument.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~%  p  q<p>    ==<p>      r1a  r1b<p>      r2a  r2b<p>      rna  rnb<p>    ==<p>  s<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgcn p=chum q=hoon r=tyre s=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>s</code>.</p>\n\n<h4>Convention</h4>\n\n<p>Register a core with name <code>p</code>, with parent at leg <code>q</code>, exporting\nthe named formulas <code>r</code>, constructed by <code>s</code>.</p>\n\n<h4>Discussion</h4>\n\n<p><code>~%</code> is for registering cores. A registered core declares its\nformal identity to the interpreter, which may or may not be able\nto recognize and/or accelerate it.</p>\n\n<p>Registered cores are organized in a containment hierarchy.\nThe parent core is at any leg within the child core. When we\nregister a core, we state the leg to its parent, in the form of\nwing <code>q</code>. We assume the parent is already registered -- as it\nmust be, if (a) we registered it on creation, (b) the child was\ncreated by an arm defined on the parent.</p>\n\n<p>(Cores are actually managed by their formula/battery. Any\nfunction call will create a new core with a new sample, but\nbatteries are constant. But it is not sufficient to match the\nbattery -- matching the semantics constrains the payload as well,\nsince the semantics of a battery may depend on any parent core\nand/or payload constant.)</p>\n\n<p>The purpose of registration is always performance-related. It\nmay involve (a) a special-purpose optimizer or \"jet\", written\nfor a specific core and checked with a Merkle hash; (b) a\ngeneral-purpose hotspot optimizer or \"JIT\"; or (c) merely a\nhotspot declaration for profiling.</p>\n\n<p>As always with hints, the programmer has no idea which of (a),\n(b), and (c) will be applied. Use <code>~%</code>\nindiscriminately on all hotspots, bottlenecks, etc, real or\nsuspected.</p>\n\n<p>The list <code>r</code> is a way for the Hoon programmer to help jet\nimplementors with named Nock formulas that act on the core.\nIn complex systems, jet implementations are often partial and\nwant to call back into userspace.</p>\n\n<p>The child core contains the parent, of course. When we register\na core, we state the leg to its parent, in the form of wing <code>q</code>.\nWe assume that the parent -- any core within the payload -- is\nalready registered.</p>\n\n<p><code>p</code> is the name of this core within its parent; <code>q</code> is the leg</p>\n\n<p>Registers a jet in core <code>s</code> so that it can be called when that code is run.</p>\n\n<h4>Examples</h4>\n\n<p>Here's the beginning of the AES core in <code>zuse.hoon</code>:</p>\n\n<p><code><pre>\n++  aes    !.\n  ~%  %aes  ..part  ~\n  |%\n  ++  ahem\n    |=  [nnk=@ nnb=@ nnr=@]\n    =&gt;\n      =+  =&gt;  [gr=(ga 8 0x11b 3) few==&gt;(fe .(a 5))]\n          [pro=pro.gr dif=dif.gr pow=pow.gr ror=ror.few]\n      =&gt;  |%\n  ..........\n</pre></code></p>\n\n<p>Here we label the entire <code>++aes</code> core for optimization.</p>\n\n<hr />\n",
    "~<": "<p><code>~&lt;</code> \"siggal\"</p>\n\n<p>Raw hint, applied to product.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~&lt;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~&lt;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<p><code>p</code> may either be a a <code>term</code> or a pair of <code>[term hoon]</code>. If it's the latter, <code>p</code>\nmay optionally be written as <code>%foo.some-hoon</code>.</p>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sggl p=$@(term [p=term q=hoon]) q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>q</code>.</p>\n\n<h4>Discussion</h4>\n\n<p><code>~&lt;</code> is only used for jet hints (<a href=\"#-sigfas\"><code>~/</code></a> and <a href=\"#-sigcen\"><code>~%</code></a>) at the\nmoment; we are not telling the interpreter something about the computation we're\nabout to perform, but rather about its product.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(make '~&lt;(%a 42)')\n  [%7 p=[%1 p=42] q=[%11 p=97 q=[%0 p=1]]]\n  (make '~&lt;(%a.+(.) 42)')\n  [%7 p=[%1 p=42] q=[%11 p=[p=97 q=[%4 p=[%0 p=1]]] q=[%0 p=1]]]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "~+": "<p><code>~+</code> \"siglus\"</p>\n\n<p>Cache a computation.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~+  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~+(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgls p=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>p</code>.</p>\n\n<h4>Convention</h4>\n\n<p>Caches the formula and subject of <code>p</code> in a local cache (generally\ntransient in the current event).</p>\n\n<h4>Examples</h4>\n\n<p>This may pause for a second:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>%.(25 |=(a=@ ?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a))))))\n  121.393\n  </pre></code></p>\n</blockquote>\n\n<p>This may make you want to press <code>ctrl-c</code>:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>%.(30 |=(a=@ ?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a))))))\n  1.346.269\n  </pre></code></p>\n</blockquote>\n\n<p>This should work fine:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>%.(100 |=(a=@ ~+(?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a)))))))\n  573.147.844.013.817.084.101\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "~/": "<p><code>~/</code> \"sigfas\"</p>\n\n<p>Jet registration for gate with registered context.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~/  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~/(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgfs p=term q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n~%(p +7 ~ q)\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p>From the kernel:</p>\n\n<p><code><pre>\n++  add\n  ~/  %add\n  |=  [a=@ b=@]\n  ^-  @\n  ?:  =(0 a)  b\n  $(a (dec a), b +(b))\n</pre></code></p>\n\n<hr />\n",
    "~&": "<p><code>~&amp;</code> \"sigpam\"</p>\n\n<p>Debugging printf.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~&amp;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~&amp;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgpm p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>q</code>.</p>\n\n<h4>Product</h4>\n\n<p>Pretty-prints <code>p</code> on the console before computing <code>q</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>This rune has no semantic effect beyond the Hoon expression <code>q</code>. It's used\nsolely to create a side-effect: printing the value of <code>p</code> to the console.</p>\n\n<p>It's most useful for debugging programs.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>~&amp;('halp' ~)\n  'halp'\n  ~</p>\n</blockquote>\n\n<blockquote>\n  <p>~&amp;  'halp'\n    ~\n  'halp'\n  ~\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "~=": "<p><code>~=</code> \"sigtis\"</p>\n\n<p>Detect duplicate.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~=  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~=(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgts p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>q</code>.</p>\n\n<h4>Convention</h4>\n\n<p>If <code>p</code> equals <code>q</code>, produce <code>p</code> instead of <code>q</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>Duplicate nouns are especially bad news in Hoon, because comparing them\ntakes O(n) time. Use <code>~=</code> to avoid this inefficiency.</p>\n\n<h4>Examples</h4>\n\n<p>This code traverses a tree and replaces all instances of <code>32</code> with\n<code>320</code>:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo |=  a=(tree)\n         ?~(a ~ ~=(a [?:(=(n.a 32) 320 n.a) $(a l.a) $(a r.a)]))</p>\n</blockquote>\n\n<blockquote>\n  <p>(foo 32 ~ ~)\n  [320 ~ ~]\n  </pre></code></p>\n</blockquote>\n\n<p>Without <code>~=</code>, it would build a copy of a completely unchanged tree. Sad!</p>\n\n<hr />\n",
    "~?": "<p><code>~?</code> \"sigwut\"</p>\n\n<p>Conditional debug printf.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~?  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~?(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgwt p=hoon q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>r</code>.</p>\n\n<h4>Convention</h4>\n\n<p>If <code>p</code> is true, prettyprints <code>q</code> on the console before computing <code>r</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>~?((gth 1 2) 'oops' ~)\n  ~</p>\n</blockquote>\n\n<blockquote>\n  <p>~?((gth 1 0) 'oops' ~)\n  'oops'\n  ~</p>\n</blockquote>\n\n<blockquote>\n  <p>~?  (gth 1 2)\n      'oops'\n    ~\n  ~</p>\n</blockquote>\n\n<blockquote>\n  <p>~?  (gth 1 0)\n      'oops'\n    ~\n  'oops'\n  ~\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "~!": "<p><code>~!</code> \"sigzap\"</p>\n\n<p>Print type on compilation fail.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ~!  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ~!(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%sgzp p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code>q</code>.</p>\n\n<h4>Convention</h4>\n\n<p>If compilation of <code>q</code> fails, prints the type of <code>p</code> in the trace.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>a\n  ! -find.a</p>\n</blockquote>\n\n<blockquote>\n  <p>~!('foo' a)\n  ! @t\n  ! find.a</p>\n</blockquote>\n\n<blockquote>\n  <p>~!  'foo'\n    a\n  ! @t\n  ! find.a\n  </pre></code></p>\n</blockquote>\n",
    "=>": "<p><code>=&gt;</code> \"tisgar\"</p>\n\n<p>Compose two expressions.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =&gt;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =&gt;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tsgr p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>the product of <code>q</code>, with the product of <code>p</code> taken as the subject.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=&gt;([a=1 b=2 c=3] b)\n  2</p>\n</blockquote>\n\n<blockquote>\n  <p>=&gt;  9  .\n  9</p>\n</blockquote>\n\n<blockquote>\n  <p>=&gt;((add 2 4) [. .])\n  [6 6]</p>\n</blockquote>\n\n<blockquote>\n  <p>=&gt;\n    |%\n    ++  foo\n      |=  [a=@ b=@]\n      [b a]\n    --\n    (foo 42 27)\n  [27 42]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=|": "<p><code>=|</code> \"tisbar\"</p>\n\n<p>Combine a named noun with the subject by \"bunting\" (producing the default value)\nof a given mold.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =|  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =|(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tsbr p=spec q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=+(*p q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>The default (or 'bunt') value of <code>p</code> is pinned to the head of the subject.\nUsually <code>p</code> includes a name for ease of reference.</p>\n\n<p>Speaking more loosely, <code>=|</code> usually \"declares a variable\" which is\n\"uninitialized,\" presumably because you'll set it in a loop or similar.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=|  a=@ud  a\n  0</p>\n</blockquote>\n\n<blockquote>\n  <p>=|  a=[@t @t @t]  a\n  ['' '' '']\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=:": "<p><code>=:</code> \"tiscol\"</p>\n\n<p>Change multiple legs in the subject.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments: the first a variable number of pairs, the second is fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =:  p1a  p1b<p>      p2a  p2b<p>      p3a  p3b<p>    ==<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =:(p1a p1b, p2a p2b, p3a p3b q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tscl p=(list (pair wing hoon)) q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=&gt;(%_(. p) q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>This rune is like <code>=.</code>, but for modifying the values of multiple legs of the subject.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=+  a=[b=1 c=2]\n    =:  c.a  4\n        b.a  3\n      ==\n    a\n  [b=3 c=4]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=,": "<p><code>=,</code> \"tiscom\"</p>\n\n<p>Expose namespace.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =,  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =,(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tscm p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>p</code> evaluates to a noun with some namespace. From within <code>q</code> you may access\n<code>p</code>'s names without a wing path (i.e., you can use face <code>b</code> rather than <code>b.p</code>).</p>\n\n<h4>Discussion</h4>\n\n<p>This is especially useful for calling arms from an imported library core or for\ncalling arms from a stdlib core repeatedly. For example, JSON reparsers like\n<code>so:dejs:format</code> and <code>of:dejs:format</code> can be called as <code>so</code> and <code>of</code> after\ndoing:</p>\n\n<p><code><pre>\n=,  dejs:format\n</pre></code></p>\n\n<h4>Examples</h4>\n\n<p>With an imported core:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>(sum -7 --7)\n  -find.sum\n  dojo: hoon expression failed</p>\n</blockquote>\n\n<blockquote>\n  <p>(sum:si -7 --7)\n  --0</p>\n</blockquote>\n\n<blockquote>\n  <p>=,  si  (sum -7 --7)\n  --0\n  </pre></code></p>\n</blockquote>\n\n<p>With a dojo-defined face:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=/  fan  [bab=2 baz=[3 qux=4]]\n    =,  fan\n    [bab qux.baz]\n  [2 4]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=.": "<p><code>=.</code> \"tisdot\"</p>\n\n<p>Change one leg in the subject.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =.  p  q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =.(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tsdt p=wing q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=&gt;(%_(. p q) r)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>Technically the <code>=.</code> rune doesn't change the subject. It creates a new subject\njust like the old one except for a changed value at <code>p</code>. Note that the mutation\nuses <a href=\"https://developers.urbit.org/reference/hoon/rune/cen#_-cencab\"><code>%_</code> (\"cencab\")</a>, so the type at <code>p</code>\ndoesn't change. Trying to change the value type results in a <code>nest-fail</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=+  a=[b=1 c=2]\n    =.  b.a  3\n    a\n  [b=3 c=2]</p>\n</blockquote>\n\n<blockquote>\n  <p>=+  a=[b=1 c=2]\n    =.(b.a 3 a)\n  [b=3 c=2]</p>\n</blockquote>\n\n<blockquote>\n  <p>=+  a=[b=1 c=2]\n    =.(b.a \"hello\" a)\n  nest-fail\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=-": "<p><code>=-</code> \"tishep\"</p>\n\n<p>Combine a new noun with the subject, inverted.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =-  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =-(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tshp p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=&gt;([q .] p)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>=-</code> is just like <code>=+</code> but its subexpressions are reversed. <code>=-</code> looks better\nthan <code>=+</code> when the expression you're pinning to the subject is much larger than\nthe expression that uses it.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo |=  a=@\n         =-  (add a b)\n         :*  %a-bunch\n             %of-stuff\n             %here\n             b=2\n             %and-perhaps-more\n         ==\n  (foo 5)\n  7\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=^": "<p><code>=^</code> \"tisket\"</p>\n\n<p>Pin the head of a pair; change a leg with the tail.</p>\n\n<h4>Syntax</h4>\n\n<p>Four arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =^  p  q<p>    r<p>  s<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =^(p q r s)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tskt p=skin q=wing r=hoon s=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=/(p -.r =.(q +.r s))\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<ul>\n<li><code>p</code> is a new name (optionally with type) to pin to the subject.</li>\n<li><code>q</code> is the name of an existing wing of the subject.</li>\n<li><code>r</code> is an expression that produces <code>[p-value new-q-value]</code>.</li>\n<li><code>s</code> is some more code to be evaluted against the modified subject.</li>\n</ul>\n\n<p>This is a bit like doing <code>=/</code> and <code>=.</code> at the same time. It's useful for state\nmachines, where you want to produce both effects and a new state. For example,\nmany arms of a Gall agent produce <code>[effects new-state]</code> in the form of a <code>(quip card _this)</code>. In the <code>++on-poke</code> arm, you might have something like:</p>\n\n<p><code><pre>\n=^  cards  state\n  (handle-poke !&lt;(action vase))\n[cards this]\n</pre></code></p>\n\n<p>This may also remind you of Haskell's State monad.</p>\n\n<h4>Examples</h4>\n\n<p>The <code>og</code> core is a stateful pseudo-random number generator.\nWe have to change the core state every time we generate a\nrandom number, so we use <code>=^</code>:</p>\n\n<p></pre></code>\n~zod:dojo> =+  rng=~(. og 420)\n           =^  r1  rng  (rads:rng 100)\n           =^  r2  rng  (rads:rng 100)\n           [r1 r2]\n[99 46]\n</pre></code></p>\n\n<hr />\n",
    "=<": "<p><code>=&lt;</code> \"tisgal\"</p>\n\n<p>Compose two expressions, inverted.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =&lt;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =&lt;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    p:q<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tsgl p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=&gt;(q p)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>=&lt;</code> is just <code>=&gt;</code> backwards.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=&lt;(b [a=1 b=2 c=3])\n  2</p>\n</blockquote>\n\n<blockquote>\n  <p>=&lt;  b\n    [a=1 b=2 c=3]\n  2</p>\n</blockquote>\n\n<blockquote>\n  <p>b:[a=1 b=2 c=3]\n  2</p>\n</blockquote>\n\n<blockquote>\n  <p>[. .]:(add 2 4)\n  [6 6]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=+": "<p><code>=+</code> \"tislus\"</p>\n\n<p>Combine a new noun with the subject.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =+  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =+(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tsls p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=&gt;([p .] q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>The subject of the <code>=+</code> expression, call it <code>a</code>, becomes the cell <code>[p a]</code> for\nthe evaluation of <code>q</code>. That is, <code>=+</code> 'pins a value', <code>p</code>, to the head of the\nsubject.</p>\n\n<p>Loosely speaking, <code>=+</code> is the simplest way of \"declaring a variable.\"</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=+  42  -\n  42</p>\n</blockquote>\n\n<blockquote>\n  <p>=+  x=42  x\n  42</p>\n</blockquote>\n\n<blockquote>\n  <p>=+  [a='foo' b='bar']  a\n  'foo'\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=;": "<p><code>=;</code> \"tismic\"</p>\n\n<p>Combine a named noun with the subject, possibly with type annotation; inverted\norder.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =;  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =;(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tsmc p=skin q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=/(p r q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>=;</code> is exactly like <code>=/</code> except that the order of its last two subexpressions\nis reversed.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo |=  a=@\n         =/   b  1\n         =;   c=@\n           :(add a b c)\n         2\n  (foo 5)\n  8\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=/": "<p><code>=/</code> \"tisfas\"</p>\n\n<p>Combine a named noun with the subject, possibly with type annotation.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =/  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =/(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tsfs p=skin q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p>if <code>p</code> is a name, (e.g. <code>a</code>):</p>\n\n<p><code><pre>\n=+(^=(p q) r)\n</pre></code></p>\n\n<p>if <code>p</code> is a name with a type (e.g., <code>a=@</code>):</p>\n\n<p><code><pre>\n=+(^-(p q) r)\n</pre></code></p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n?@  p\n  =+  p=q\n  r\n=+  ^-($=(p.p q.p) q)\nr\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>p</code> can be either a name or a <code>name=type</code>. If it's just a name, <code>=/</code> (\"tisfas\")\n\"declares a type-inferred variable.\" If it has a type, <code>=/</code> \"declares a\ntype-checked variable.\"</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=/  a=@t  'hello'  a\n  'hello'</p>\n</blockquote>\n\n<blockquote>\n  <p>=/  x  [1 2 3]  x\n  [1 2 3]</p>\n</blockquote>\n\n<blockquote>\n  <p>=foo |=  a=@\n         =/  b  1\n         =/  c=@  2\n         :(add a b c)\n  (foo 5)\n  8\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=~": "<p><code>=~</code> \"tissig\"</p>\n\n<p>Compose many expressions.</p>\n\n<h4>Syntax</h4>\n\n<p>Variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =~  p1<p>      p2<p>      p3<p>      pn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =~(p1 p2 p3 pn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tssg p=(list hoon)]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>The product of the chain composition.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=~  10\n        [20 .]\n        [30 .]\n        [40 .]\n        .\n    ==\n  [40 30 20 10]</p>\n</blockquote>\n\n<blockquote>\n  <p>=~  [sub (mul 3 20) (add 10 20)]\n        (sub +)\n        +(.)\n    ==\n  31</p>\n</blockquote>\n\n<blockquote>\n  <p>=foo =|  n=@\n         =&lt;  =~  increment\n                 increment\n                 increment\n                 n\n             ==\n         |%\n         ++  increment\n           ..increment(n +(n))\n         --\n  foo\n  3\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=*": "<p><code>=*</code> \"tistar\" {% #-tistar %}</p>\n\n<p>Define a deferred expression.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =*  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =*(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tstr p=term q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>r</code>, compiled with a subject in which <code>p</code> is a deferred expression for <code>q</code>.</p>\n\n<h4>Discussion</h4>\n\n<p><code>=*</code> assigns a name to an expression that will be evaluated in each place the\nname is dereferenced. This allows you to \"write\" through it to the original\nsubject <code>axis</code>. <code>q</code> is recorded in the type information of <code>p</code>, and <code>q</code> is\ncalculated every time you use <code>p</code>.</p>\n\n<p>This rune has some similarities with macros, and some similarities with aliases,\nbut it is not really either.</p>\n\n<p>This rune is commonly used to give a Gall agent's state the name <code>state</code> like:</p>\n\n<p><code><pre>\n=*  state  -\n</pre></code></p>\n\n<p>This lets you reference the whole <code>state</code> while also being able to reference its\nindividual elements like <code>foo</code> and <code>bar</code>, without having to do <code>foo.state</code>,\n<code>bar.state</code>, etc.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=+  a=1\n    =*  b  a\n    [a b]\n  [1 1]</p>\n</blockquote>\n\n<blockquote>\n  <p>=+  a=1\n    =*  b  a\n    =.  a  2\n    [a b]\n  [2 2]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "=?": "<p><code>=?</code> \"tiswut\"</p>\n\n<p>Conditionally change one leg in the subject.</p>\n\n<h4>Syntax</h4>\n\n<p>Four arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  =?  p  q<p>    r<p>  s<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  =?(p q r s)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%tswt p=wing q=hoon r=hoon s=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n=.  p  ?:(q r p)\ns\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>Use <code>=?</code> to replace the value of leg <code>p</code> with <code>r</code> on condition <code>q</code>. As\nusual, we are not actually mutating the subject, just creating\na new subject with a changed value. The change in value includes a\ntype check against the old subject; the type of <code>r</code> must nest under\nthe type of <code>p</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=a 12</p>\n</blockquote>\n\n<blockquote>\n  <p>=?(a =(1 1) 22 a)\n  22</p>\n</blockquote>\n\n<blockquote>\n  <p>=?(a =(1 2) 22 a)\n  12\n  </pre></code></p>\n</blockquote>\n",
    "?|": "<p><code>?|</code> \"wutbar\"</p>\n\n<p>Logical OR.</p>\n\n<h4>Syntax</h4>\n\n<p>Variable number of arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?|  p1<p>      p2<p>      p3<p>      pn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?|(p1 p2 p3 pn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    |(p1 p2 p3 pn)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtbr p=(list hoon)]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><strong>Pseudocode</strong>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>p</code>:</p>\n\n<p><code><pre>\n?:(a &amp; ?:(b &amp; ?:(c &amp; ?:(... ?:(z &amp; |)))))\n</pre></code></p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n|-\n?~  p\n  |\n?:  i.p\n  &amp;\n$(p t.p)\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>If any argument evaluates to true (<code>%.y</code>), true. If all arguments evaluate to\nfalse (<code>%.n</code>), false.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>|(=(6 42) =(42 42))\n  %.y</p>\n</blockquote>\n\n<blockquote>\n  <p>|(=(6 42) =(42 43))\n  %.n\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?-": "<p><code>?-</code> \"wuthep\"</p>\n\n<p>Switch against a union, with no default.</p>\n\n<h4>Syntax</h4>\n\n<p>One fixed argument, then a variable number of pairs.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall style #1</td>\n  <td style=\"text-align:center;\"><pre>  ?-  p<p>    q1a  q1b<p>    q2a  q2b<p>    qna  qnb<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Tall style #2</td>\n  <td style=\"text-align:center;\"><pre>  ?-    p<p>      q1a<p>    q1b<p>  ::<p>      q2a<p>    q2b<p>  ::<p>      qna<p>    qnb<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?-(p q1a q1b, q2a q2b, qna qnb)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wthp p=wing q=(list (pair spec value))]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><strong>Pseudocode</strong>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>q</code>:</p>\n\n<p><code><pre>\n?:  ?=(p.a p)  q.a\n?:  ?=(p.b p)  q.b\n?:  ?=(p.c p)  q.c\n...\n~|(%mint-lost !!)\n</pre></code></p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n|-\n?.  q\n  ~|(%mint-lost !!)\n?:  ?=(p.i.q p)\n  q.i.q\n$(q t.q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>The <code>?-</code> rune is for a conditional expression in which the type of <code>p</code>\ndetermines which branch is taken. Usually the type of <code>p</code> is a union of other\ntypes. There is no default branch.</p>\n\n<p>The compiler makes sure that your code neither misses a case of the union, nor\nincludes a double case that isn't there. This is not special handling for <code>?-</code>,\njust a consequence of the semantics of <code>?:</code>, which <code>?-</code> reduces to.</p>\n\n<p>A missing case will throw the <code>mint-lost</code> error. An extra case will throw\n<code>mint-vain</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=cor |=  vat=?(%a %b)\n         ?-  vat\n           %a  20\n           %b  42\n         ==</p>\n</blockquote>\n\n<blockquote>\n  <p>(cor %a)\n  20</p>\n</blockquote>\n\n<blockquote>\n  <p>(cor %b)\n  42</p>\n</blockquote>\n\n<blockquote>\n  <p>(cor %c)\n  ! nest-fail\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?:": "<p><code>?:</code> \"wutcol\" {% #-wutcol %}</p>\n\n<p>Branch on a boolean test.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?:  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?:(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtcl p=hoon q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>If <code>p</code> produces true (<code>%.y</code>), then <code>q</code>. If <code>p</code> produces false (<code>%.n</code>), then <code>r</code>.\nIf <code>p</code> is not a boolean, compiler yells at you.</p>\n\n<h4>Discussion</h4>\n\n<p>If test analysis reveals that either branch is never taken, or if <code>p</code> is not a\nboolean, compilation fails. An untaken branch is indicated with <code>mint-lost</code>.</p>\n\n<p>Note also that all other branching expressions reduce to <code>?:</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>?:((gth 1 0) 3 4)\n  3</p>\n</blockquote>\n\n<blockquote>\n  <p>?:  (gth 1 0)\n      3\n    4\n  3</p>\n</blockquote>\n\n<blockquote>\n  <p>?:((gth 1 2) 3 4)\n  4</p>\n</blockquote>\n\n<blockquote>\n  <p>?:  (gth 1 2)\n      3\n    4\n  4\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?.": "<p><code>?.</code> \"wutdot\"</p>\n\n<p>Branch on a boolean test, inverted.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?.  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?.(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtdt p=hoon q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n?:(p r q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>?.</code> is just like <code>?:</code>, but with its last two subexpressions reversed.</p>\n\n<p>As is usual with inverted forms, use <code>?.</code> when the true-case expression is much\ntaller and/or wider than the false-case expression.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>?.((gth 1 2) 3 4)\n  3</p>\n</blockquote>\n\n<blockquote>\n  <p>?.(?=(%a 'a') %not-a %yup)\n  %yup</p>\n</blockquote>\n\n<blockquote>\n  <p>?.  %.y\n      'this false case is less heavy than the true case'\n    ?:  =(2 3)\n      'two not equal to 3'\n    'but see how \\'r is much heavier than \\'q?'\n  'but see how \\'r is much heavier than \\'q?'\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?^": "<p><code>?^</code> \"wutket\"</p>\n\n<p>Branch on whether a wing of the subject is a cell.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?^  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?^(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtkt p=wing q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n?:(?=(^ p) q r)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>The type of the wing, <code>p</code>, must not be known to be either an atom or a cell, or\nelse you'll get a <code>mint-vain</code> error at compile time. <code>mint-vain</code> means that one\nof the <code>?^</code> branches, <code>q</code> or <code>r</code>, is never taken.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>?^(0 1 2)\n  ! mint-vain\n  ! exit</p>\n</blockquote>\n\n<blockquote>\n  <p>?^(<code>*</code>0 1 2)\n  2</p>\n</blockquote>\n\n<blockquote>\n  <p>?^(<code>*</code>[1 2] 3 4)\n  3\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?<": "<p><code>?&lt;</code> \"wutgal\"</p>\n\n<p>Negative assertion.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?&lt;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?&lt;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtgl p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n?:(p !! q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>?&lt;</code> is used to force a crash when some condition <code>p</code> doesn't yield false\n(<code>%.n</code>). It can be used for type inference with the <code>?=</code> rune, much like the\n<code>?&gt;</code> rune.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>?&lt;(=(3 4) %foo)\n  %foo</p>\n</blockquote>\n\n<blockquote>\n  <p>?&lt;(=(3 3) %foo)\n  dojo: hoon expression failed</p>\n</blockquote>\n\n<blockquote>\n  <p>=a <code>*</code>[12 14]</p>\n</blockquote>\n\n<blockquote>\n  <p><code>^</code>a\n  nest-fail</p>\n</blockquote>\n\n<blockquote>\n  <p>?&lt;(?=(@ a) <code>^</code>a)\n  [12 14]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?>": "<p><code>?&gt;</code> \"wutgar\"</p>\n\n<p>Positive assertion.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?>  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?>(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtgr p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n?.(p !! q)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>?&gt;</code> is used to force a crash when some condition <code>p</code> doesn't yield true\n(<code>%.y</code>). It can be used for type inference, with the <code>?=</code> rune, to specify the\ntype of a value.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>?>(=(3 3) %foo)\n  %foo</p>\n</blockquote>\n\n<blockquote>\n  <p>?>(=(3 4) %foo)\n  dojo: hoon expression failed</p>\n</blockquote>\n\n<blockquote>\n  <p>=a <code>*</code>123</p>\n</blockquote>\n\n<blockquote>\n  <p><code>@</code>a\n  nest-fail</p>\n</blockquote>\n\n<blockquote>\n  <p>?>(?=(@ a) <code>@</code>a)\n  123\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?+": "<p><code>?+</code> \"wutlus\"</p>\n\n<p>Switch against a union, with a default.</p>\n\n<h4>Syntax</h4>\n\n<p>Two fixed arguments, then a variable number of pairs.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall style #1</td>\n  <td style=\"text-align:center;\"><pre>  ?+  p  q<p>    r1a  r1b<p>    r2a  r2b<p>    rna  rnb<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Tall style #2</td>\n  <td style=\"text-align:center;\"><pre>  ?+    p  q<p>      r1a<p>    r1b<p>  ::<p>      r2a<p>    r2b<p>  ::<p>      rna<p>    rnb<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?+(p q r1a r1b, r2a r2b, rna rnb)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtls p=wing q=hoon r=(list (pair spec hoon))]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><strong>Pseudocode</strong>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>r</code>:</p>\n\n<p><code><pre>\n?:  ?=(p.a p)  q.a\n?:  ?=(p.b p)  q.b\n?:  ?=(p.c p)  q.c\n...\nq\n</pre></code></p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n|-\n?.  r\n  q\n?:  ?=(p.i.r p)\n  q.i.r\n$(r t.r)\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>The <code>?+</code> rune is for a conditional expression in which the type of <code>p</code>\ndetermines which branch is taken. Usually the type of <code>p</code> is a union of other\ntypes. If <code>p</code>'s type doesn't match the case for any given branch, the default\nexpression, <code>q</code>, is evaluated.</p>\n\n<p>If there is a case that is never taken you'll get a <code>mint-vain</code> error.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=cor |=  vat=@tas\n         ?+  vat  240\n           %a  20\n           %b  42\n         ==</p>\n</blockquote>\n\n<blockquote>\n  <p>(cor %a)\n  20</p>\n</blockquote>\n\n<blockquote>\n  <p>(cor %b)\n  42</p>\n</blockquote>\n\n<blockquote>\n  <p>(cor %c)\n  240\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?&": "<p><code>?&amp;</code> \"wutpam\"</p>\n\n<p>Logical AND.</p>\n\n<h4>Syntax</h4>\n\n<p>Variable arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?&amp;  p1<p>      p2<p>      pn<p>  ==<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?&amp;(p1 p2 pn)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre><p>    &amp;(p1 p2 pn)<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtpm p=(list hoon)]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><strong>Pseudocode</strong>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>p</code>:</p>\n\n<p><code><pre>\n?.(a | ?.(b | ?.(c | ?.(... ?.(z | &amp;)))))\n</pre></code></p>\n\n<h4>Desugaring</h4>\n\n<p><code><pre>\n|-\n?~  p\n  &amp;\n?.  i.p\n  |\n$(p t.p)\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>If ALL arguments evaluate to true (<code>%.y</code>), true (<code>%.y</code>). If one or more evalute\nto false (<code>%.n</code>), false (<code>%.n</code>).</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>&amp;(=(6 6) =(42 42))\n  %.y</p>\n</blockquote>\n\n<blockquote>\n  <p>&amp;(=(6 7) =(42 42))\n  %.n\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?@": "<p><code>?@</code> \"wutpat\"</p>\n\n<p>Branch on whether a wing of the subject is an atom.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?@  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?@(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtpt p=wing q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n?:(?=(@ p) q r)\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>If <code>p</code> is an atom, <code>q</code>. If <code>p</code> is a cell, <code>r</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>The type of the wing, <code>p</code>, must not be known to be either an atom or a cell, or\nelse you'll get a <code>mint-vain</code> error at compile time. <code>mint-vain</code> means that one\nof the <code>?@</code> branches, <code>q</code> or <code>r</code>, is never taken.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>?@(0 1 2)\n  ! mint-vain\n  ! exit</p>\n</blockquote>\n\n<blockquote>\n  <p>?@(<code>*</code>0 1 2)\n  1</p>\n</blockquote>\n\n<blockquote>\n  <p>?@(<code>*</code>[1 2] 3 4)\n  4\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?~": "<p><code>?~</code> \"wutsig\"</p>\n\n<p>Branch on whether a wing of the subject is null.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?~  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?~(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtsg p=wing q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n?:(?=($~ p) q r)\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>If <code>p</code> is null (<code>~</code>), <code>q</code>. If <code>p</code> is non-null, <code>r</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>It's bad style to use <code>?~</code> to test for any zero atom. Use it only for a true\nnull, <code>~</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo \"\"</p>\n</blockquote>\n\n<blockquote>\n  <p>?~(foo 1 2)\n  1\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?=": "<p><code>?=</code> \"wuttis\"</p>\n\n<p>Test pattern match.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?=  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?=(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtts p=spec q=wing]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p><code>%.y</code> (true) if the noun at <code>q</code> is in the type of <code>p</code>; <code>%.n</code> (false) otherwise.</p>\n\n<h4>Discussion</h4>\n\n<p><code>?=</code> is not as powerful as it might seem. For instance, it\ncan't generate a loop -- you cannot (and should not) use it to\ntest whether a <code>*</code> is a <code>(list @)</code>. Nor can it validate atomic\nauras.</p>\n\n<p>Patterns should be as weak as possible. Unpack one layer of\nunion at a time. Don't confirm things the type system knows.</p>\n\n<p>For example, when matching from a tagged union for the type <code>[%foo p=@ q=[@ @]]</code>, the appropriate pattern is <code>[%foo *]</code>. You have one\nquestion, which is whether the head of the noun is <code>%foo</code>.</p>\n\n<p>A common error is <code>find.$</code>, meaning <code>p</code> is not a type.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=bar [%foo %bar %baz]\n  ?=([%foo *] bar)\n  %.y\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "?!": "<p><code>?!</code> \"wutzap\"</p>\n\n<p>Logical NOT.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  ?!  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  ?!(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\"><pre>    !p<p>  </pre></td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%wtzp p=hoon]\n</pre></code></p>\n\n<h4>Expands to</h4>\n\n<p><code><pre>\n.=(| p)\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>The logical NOT of <code>p</code>, which must evaluate to either <code>%.y</code> or <code>%.n</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code>\n~zod:dojo> ?!(.=(1 2))\n%.y</p>\n\n<p>~zod:dojo> !&amp;\n%.n</p>\n\n<p>~zod:dojo> !|\n%.y</p>\n\n<p>~zod:dojo> !(gth 5 6)\n%.y\n</pre></code></p>\n",
    "!,": "<p><code>!,</code> \"zapcom\"</p>\n\n<p>Produce the Hoon AST of an expression.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !,  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  !,(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%zpcm p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>This produces the <a href=\"https://developers.urbit.org/reference/hoon/stdlib/4o#hoon\"><code>$hoon</code></a> AST of\nexpression <code>q</code>. The first argument, <code>p</code>, is always an example of the <code>$hoon</code>\ntype, typically just the <code>*hoon</code> bunt value, and is used for type inference. The\nreason for <code>p</code> is just to handle transitions if the <code>$hoon</code> type changes.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>!,  *hoon  [1 1]\n  [%cltr p=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]</p>\n</blockquote>\n\n<blockquote>\n  <p>!,  *hoon  (add 1 1)\n  [%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "!>": "<p><code>!&gt;</code> \"zapgar\"</p>\n\n<p>Wrap a noun in its type (form a <a href=\"https://developers.urbit.org/reference/hoon/stdlib/4o#vase\"><code>vase</code></a>).</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !>  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  !>(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%zpgr p=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>A cell whose tail is the product of <code>p</code>, and whose head is the static type of <code>p</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>In Hoon, a dynamic type is a static type compiled at runtime. This type-noun\ncell is generally called a <a href=\"https://developers.urbit.org/reference/hoon/stdlib/4o#vase\"><code>vase</code></a>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>!>(1)\n  [#t/@ud q=1]\n  </pre></code></p>\n</blockquote>\n\n<p>If you want just the type value, use a 'type spear'. This is <code>-:!&gt;</code>, i.e., the\nhead of the cell produced by <code>!&gt;</code>:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>-:!>(1)</p>\n  \n  <h1>t/@ud</h1>\n</blockquote>\n\n<p></pre></code></p>\n\n<hr />\n",
    "!<": "<p><code>!&lt;</code> \"zapgal\"</p>\n\n<p>Extracts a <a href=\"https://developers.urbit.org/reference/hoon/stdlib/4o#vase\"><code>vase</code></a> to the given mold if\nits type nests.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !&lt;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  !&lt;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%zpgl p=spec q=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>The value of vase <code>q</code> typed with the type of mold <code>p</code> if possible, else a\n<code>nest-fail</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>This is something like a partial inverse to the <code>!&gt;</code> rune and can be used to\nextract a typed value from a <code>vase</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>!&lt;  @  !>  ~zod\n  0</p>\n</blockquote>\n\n<blockquote>\n  <p>!&lt;  @p  !>  0\n  nest-fail</p>\n</blockquote>\n\n<blockquote>\n  <p>!&lt;  tape  !>(\"foobar\")\n  \"foobar\"\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "!;": "<p><code>!;</code> \"zapmic\"</p>\n\n<p>Wrap a noun in its type (raw).</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !;  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  !;(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%zpmc p=hoon q=hoon]\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p>This wraps the product of <code>q</code> in its inferred type. It's a raw version of\n<a href=\"#-zapgar\"><code>!&gt;</code></a>. Unlike zapgar, <code>q</code> is not given a <code>p</code> face and its type\ninformation is not stripped to a raw noun.</p>\n\n<p>The first field, <code>p</code>, must be an example of the\n<a href=\"https://developers.urbit.org/reference/hoon/stdlib/4o#type\"><code>$type</code></a> type, typically just <code>*type</code> (the\nbunt of <code>$type</code>). The <code>p</code> argument is just so transitions can be handled if the\n<code>$type</code> type changes.</p>\n\n<p>It's unlikely you'd use this rune directly; <a href=\"#-zapgar\"><code>!&gt;</code></a> is much more\ntypical.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>!;  *type  [1 1]\n  [#t/[@ud @ud] 1 1]</p>\n</blockquote>\n\n<blockquote>\n  <p>!;  *type  'foo'\n  [#t/@t 'foo']\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "!=": "<p><code>!=</code> \"zaptis\"</p>\n\n<p>Make the Nock formula for a Hoon expression.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !=  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  !=(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%zpts p=hoon]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>The Nock generated by <code>p</code>.</p>\n\n<h4>Discussion</h4>\n\n<p>Don't confuse <code>!=</code> with a negation, <code>!</code>, followed by a test for equality, <code>=(10 11)</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>!=(20)\n  [1 20]</p>\n</blockquote>\n\n<blockquote>\n  <p>!=(~zod)\n  [1 0]</p>\n</blockquote>\n\n<blockquote>\n  <p>!=((add 2 2))\n  [8 [9 3.110.356 0 31] 9 2 [0 4] [7 [0 3] 1 2 2] 0 11]\n  </pre></code></p>\n</blockquote>\n\n<p>Don't confuse the <code>!=</code> rune with:</p>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>!=(10 11)\n  %.y</p>\n</blockquote>\n\n<blockquote>\n  <p>!=(10 10)\n  %.n\n  </pre></code></p>\n</blockquote>\n\n<p>The syntax difference is that a test for equality takes two subexpressions, and\nthe <code>!=</code> rune only one.</p>\n\n<hr />\n",
    "!?": "<p><code>!?</code> \"zapwut\"</p>\n\n<p>Restrict Hoon version.</p>\n\n<h4>Syntax</h4>\n\n<p>Two arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !?  p<p>  q<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  !?(p q)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%zpwt p=$@(p=@ [p=@ q=@]) q=hoon]</p>\n\n</pre></code>\n\n<h4>Produces</h4>\n\nWhen `p` is an atom:\n\n<ul>\n\n<p><li><code>q</code> if <code>p</code> \u2265 Hoon kelvin version, otherwise crash.</li></p>\n\n</ul>\n\nWhen `p` is a cell:\n\n<ul>\n\n<p><li><code>q</code>, if <code>p.p</code> \u2265 Hoon kelvin version \u2265 <code>q.p</code>, otherwise crash.</li>\n</ul></p>\n\n<p>(Versions count down; the current version is 140.)</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>!?  [142 140]  (add 2 2)\n  4</p>\n</blockquote>\n\n<blockquote>\n  <p>!?  142  (add 2 2)\n  4</p>\n</blockquote>\n\n<blockquote>\n  <p>!?  64  (add 2 2)\n  ! exit\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "!@": "<p><code>!@</code> \"zappat\"</p>\n\n<p>Branch on whether a wing exists.</p>\n\n<h4>Syntax</h4>\n\n<p>Three arguments, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !@  p<p>    q<p>  r<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  !@(p q r)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%zppt p=(list wing) q=hoon r=hoon]\n</pre></code></p>\n\n<h4>Discussion</h4>\n\n<p><code>p</code> is a wing reference like <code>foo</code>, <code>bar.foo</code>, etc. If <code>p</code> exists, <code>q</code>. If <code>p</code>\ndoes not exist, <code>r</code>. Essentially, this is like <code>?:</code> for wing existence.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>=foo 42</p>\n</blockquote>\n\n<blockquote>\n  <p>!@(foo 'exists' 'does not exist')\n  'exists'</p>\n</blockquote>\n\n<blockquote>\n  <p>!@(baz 'exists' 'does not exist')\n  'does not exist'\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "!!": "<p><code>!!</code> \"zapzap\"</p>\n\n<p>Crash.</p>\n\n<h4>Syntax</h4>\n\n<p>No arguments.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !!<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre><p>  !!<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>AST</h4>\n\n<p><code><pre>\n[%zpzp ~]\n</pre></code></p>\n\n<h4>Produces</h4>\n\n<p>Nothing. Always crashes, with type <code>%void</code>.</p>\n\n<h4>Discussion</h4>\n\n<p><code>%void</code> nests in every other type, so you can stub out anything with <code>!!</code>.</p>\n\n<h4>Examples</h4>\n\n<p></pre></code></p>\n\n<blockquote>\n  <p>!!\n  dojo: hoon expression failed\n  </pre></code></p>\n</blockquote>\n\n<hr />\n",
    "!:": "<p><code>!:</code> \"zapcol\"</p>\n\n<p>Turn on stack trace.</p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !:  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  !:(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>Produces</h4>\n\n<p>The product of <code>p</code> unless <code>p</code> crashes, in which case a stack trace is given.</p>\n\n<h4>Discussion</h4>\n\n<p><code>!:</code> is used to turn on a debugging stack trace option for any code you have in\n<code>p</code>.</p>\n\n<h4>Examples</h4>\n\n</pre></code>\n<blockquote>\n\n<p><p>?:(=(0 1) 123 !!)\n  dojo: hoon expression failed</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p>!:  ?:(=(0 1) 123 !!)\n  /~zod/base/~2022.4.2..08.54.53..07d7:&lt;[1 5].[1 22]&gt;\n  /~zod/base/~2022.4.2..08.54.53..07d7:&lt;[1 19].[1 21]&gt;\n  dojo: hoon expression failed\n  </pre></code></p>\n</blockquote></p>\n\n<hr />\n",
    "!.": "<p><code>!.</code> \"zapdot\"</p>\n\n<p>Turn off stack trace for a subexpression <code>p</code></p>\n\n<h4>Syntax</h4>\n\n<p>One argument, fixed.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">Form</th>\n  <th style=\"text-align:center;\">Syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">Tall</td>\n  <td style=\"text-align:center;\"><pre>  !.  p<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Wide</td>\n  <td style=\"text-align:center;\"><pre>  !.(p)<p>  </pre></td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">Irregular</td>\n  <td style=\"text-align:center;\">None.</td>\n</tr>\n</tbody>\n</table>\n\n<h4>Produces</h4>\n\n<p>The product of <code>p</code>. If <code>p</code> crashes, no stack trace entries are given for that code.</p>\n\n<h4>Discussion</h4>\n\n<p><code>!.</code> is used to turn off a debugging stack trace option for any code you have in\n<code>p</code>. This rune can be embedded under a <code>!:</code> rune for inner loops of your code\nthat you don't want or need to trace. This is especially useful if a trace\noverflows the stack.</p>\n\n<h4>Examples</h4>\n\n</pre></code>\n<blockquote>\n\n<p><p>%.(1 |=(a=@ ^-(@ ?:(=(a 10) !! $(a +(a))))))\n  dojo: hoon expression failed</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p>!:  %.(1 |=(a=@ ^-(@ ?:(=(a 10) !! $(a +(a))))))\n  /~zod/base/~2022.4.2..08.56.45..5ecc:&lt;[1 5].[1 49]&gt;\n  /~zod/base/~2022.4.2..08.56.45..5ecc:&lt;[1 17].[1 47]&gt;\n  /~zod/base/~2022.4.2..08.56.45..5ecc:&lt;[1 22].[1 46]&gt;\n  ...skipping some lines...\n  /~zod/base/~2022.4.2..08.56.45..5ecc:&lt;[1 22].[1 46]&gt;\n  /~zod/base/~2022.4.2..08.56.45..5ecc:&lt;[1 33].[1 35]&gt;\n  dojo: hoon expression failed</p></p>\n\n</blockquote>\n\n\n<blockquote>\n\n<p><p>!:  %.(1 !.(|=(a=@ ^-(@ ?:(=(a 10) !! $(a +(a)))))))\n  /~zod/base/~2022.4.2..08.57.07..d40b:&lt;[1 5].[1 53]&gt;\n  dojo: hoon expression failed\n  </pre></code></p>\n</blockquote></p>\n\n<hr />\n"
}